{"file_contents":{"nz-apostas/DEPLOY_RAILWAY.md":{"content":"\n# Deploy do Bot NZ Apostas no Railway\n\nEste guia explica como fazer o deploy do bot Discord no Railway.\n\n## ✨ Detecção Automática de Ambiente\n\nO bot **detecta automaticamente** quando está rodando no Railway através das variáveis de ambiente `RAILWAY_ENVIRONMENT` ou `RAILWAY_STATIC_URL`. Você não precisa fazer nenhuma configuração adicional!\n\nQuando detectado no Railway, o bot:\n- 🚂 Exibe mensagem \"Detectado ambiente Railway\"\n- 📁 Usa o diretório `/app/data` para dados persistentes\n- 🔍 Mostra traceback completo de erros\n- ⚙️ Usa configurações de logging otimizadas\n\n## Pré-requisitos\n\n1. Conta no [Railway](https://railway.app/)\n2. Token do bot Discord configurado\n3. Código do bot no GitHub (ou upload direto)\n\n## Passo a Passo\n\n### 1. Preparar o Repositório\n\nSe você ainda não tem o código no GitHub:\n\n1. Crie um novo repositório no GitHub\n2. Faça upload de todos os arquivos da pasta `nz-apostas`\n3. Certifique-se de que os arquivos `railway.json`, `Procfile`, `runtime.txt` e `requirements.txt` estão incluídos\n\n### 2. Criar Projeto no Railway\n\n1. Acesse [railway.app](https://railway.app/)\n2. Faça login com sua conta GitHub\n3. Clique em **\"New Project\"**\n4. Selecione **\"Deploy from GitHub repo\"**\n5. Escolha o repositório com o código do bot\n6. Railway detectará automaticamente que é um projeto Python\n\n### 3. Configurar Variáveis de Ambiente\n\n1. No dashboard do projeto, vá em **\"Variables\"**\n2. Adicione a seguinte variável:\n   - `TOKEN`: Cole o token do seu bot Discord\n\n**IMPORTANTE:** \n- Nunca compartilhe ou commite o token do bot no GitHub!\n- O Railway define automaticamente `RAILWAY_ENVIRONMENT` e `RAILWAY_STATIC_URL`\n\n### 4. Configurar Deploy\n\nRailway detectará automaticamente o `railway.json` e `Procfile`. Se necessário:\n\n1. Vá em **\"Settings\"**\n2. Em **\"Deploy\"**, confirme que:\n   - **Start Command**: `python main.py`\n   - **Build Command**: (deixe em branco, Railway instalará dependências automaticamente)\n\n### 5. Deploy\n\n1. Railway iniciará o deploy automaticamente\n2. Aguarde a instalação das dependências\n3. O bot iniciará quando o deploy estiver completo\n4. Verifique os logs em **\"Deployments\"** → **\"View Logs\"**\n\n### 6. Verificar Status\n\nPara confirmar que o bot está online:\n\n1. Verifique os logs do Railway\n2. Procure por mensagens como:\n   ```\n   🚂 Detectado ambiente Railway\n   Iniciando bot no Railway...\n   Bot conectado como NZ apostas#1303\n   Nome: NZ apostas\n   ID: 1431031103401103474\n   8 comandos sincronizados\n   ```\n3. Teste um comando no Discord\n\n## Troubleshooting\n\n### Bot não conecta\n\n- Verifique se o `TOKEN` está configurado corretamente nas variáveis de ambiente\n- Confirme que o token é válido no [Discord Developer Portal](https://discord.com/developers/applications)\n- Verifique os logs completos no Railway (o bot mostra traceback detalhado)\n\n### Erros de dependências\n\n- Verifique se o arquivo `requirements.txt` está presente\n- Confirme que `discord.py==2.6.4` está listado\n\n### Bot desconecta frequentemente\n\n- Railway oferece planos gratuitos com limitações\n- Considere fazer upgrade para um plano pago para melhor estabilidade\n\n### Logs não aparecem\n\n- Vá em **\"Deployments\"** → clique no deploy ativo → **\"View Logs\"**\n- Os logs podem levar alguns segundos para aparecer\n- Procure pela mensagem \"🚂 Detectado ambiente Railway\"\n\n### Banco de dados não persiste\n\n- Configure um Volume no Railway (veja seção abaixo)\n- Monte o volume em `/app/data`\n\n## Estrutura de Arquivos Necessária\n\n```\nnz-apostas/\n├── main.py                 # Código principal do bot (com detecção Railway)\n├── models/\n│   ├── __init__.py\n│   └── bet.py\n├── utils/\n│   ├── __init__.py\n│   └── database.py        # Sistema de dados (com suporte Railway)\n├── data/\n│   └── bets.json          # Será criado automaticamente\n├── requirements.txt       # Dependências Python\n├── runtime.txt            # Versão do Python\n├── Procfile              # Comando de start\n├── railway.json          # Configuração Railway\n└── README.md\n```\n\n## Persistência de Dados\n\n**ATENÇÃO:** O Railway não mantém arquivos entre deploys por padrão. O arquivo `data/bets.json` será perdido em cada redeploy.\n\n### Soluções:\n\n1. **Railway Volumes** (Recomendado):\n   ```bash\n   # O bot detectará automaticamente o volume se montado em /app/data\n   ```\n   - No Railway, vá em **\"Settings\"** → **\"Volumes\"**\n   - Crie um novo volume\n   - Monte-o em `/app/data`\n   - O bot usará automaticamente este diretório\n\n2. **Banco de Dados Externo**:\n   - Use PostgreSQL, MongoDB ou outro banco\n   - Railway oferece add-ons de banco de dados\n\n3. **Armazenamento em Nuvem**:\n   - Use S3, Google Cloud Storage, etc.\n   - Sincronize o `bets.json` periodicamente\n\n## Monitoramento\n\n- **Logs**: Railway → Deployments → View Logs\n  - Procure por \"🚂 Detectado ambiente Railway\"\n  - Erros mostram traceback completo\n- **Métricas**: Railway → Observability\n- **Alertas**: Configure notificações no Discord para erros\n\n## Redeploy Automático\n\nRailway faz redeploy automático quando você:\n- Faz push para o branch principal do GitHub\n- Modifica variáveis de ambiente\n- Clica em \"Redeploy\" manualmente\n\n## Custos\n\n- **Plano Gratuito**: \n  - $5 em créditos por mês\n  - 500 horas de execução\n  - Ideal para testes\n\n- **Plano Hobby**: \n  - $5/mês + uso\n  - Sem limite de horas\n  - Recomendado para produção\n\n## Suporte\n\n- [Documentação Railway](https://docs.railway.app/)\n- [Discord da Railway](https://discord.gg/railway)\n- [Status do Railway](https://status.railway.app/)\n\n## Diferenças vs Replit\n\n| Recurso | Replit | Railway |\n|---------|--------|---------|\n| Deploy Automático | ✅ | ✅ |\n| Detecção de Ambiente | ✅ | ✅ Automática |\n| Persistência | ✅ Built-in | ⚠️ Requer Volume |\n| Logs | ✅ | ✅ Mais detalhados |\n| Custo Gratuito | Limitado | $5 créditos/mês |\n| Uptime | Bom | Excelente |\n| Facilidade | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |\n\n## Próximos Passos\n\n1. ✅ Deploy inicial (detecção automática funciona!)\n2. Configure um volume persistente para `/app/data`\n3. Adicione monitoramento de erros\n4. Configure backup automático dos dados\n5. Implemente health checks\n\n---\n\n**Nota**: Este bot está atualmente deployado no Replit. Esta é apenas uma cópia de backup para Railway que detecta automaticamente o ambiente.\n","size_bytes":6467},"nz-apostas/INSTRUCOES.md":{"content":"# 🎮 NZ Apostado - Bot de Apostas Discord\n\nSistema completo de apostas para Discord com filas, mediadores e gerenciamento automático de canais.\n\n## 📋 Funcionalidades Implementadas\n\n✅ **Sistema de Filas por Modo**\n- 1v1 Misto\n- 1v1 Mob\n- 2v2 Misto\n\n✅ **Criação Automática de Canais Privados**\n- Quando 2 jogadores entram na mesma fila, um canal privado é criado automaticamente\n- Sistema de botão para ADMs aceitarem mediação\n- Cada mediador insere sua própria chave PIX\n\n✅ **Sistema de Confirmação de Pagamento**\n- Cada jogador confirma que enviou o pagamento\n- Mediador recebe notificações das confirmações\n\n✅ **Finalização de Apostas**\n- Mediador declara o vencedor\n- Canal é automaticamente deletado após 30 segundos\n\n✅ **Sistema Anti-Duplicação**\n- Jogadores só podem estar em uma aposta ativa por vez\n\n✅ **Logs e Histórico**\n- Todas as apostas são registradas\n- Histórico acessível por comando\n\n## 🚀 Como Configurar\n\n### 1. Habilitar Intents no Portal do Discord\n\n**IMPORTANTE:** O bot precisa de intents privilegiados habilitados. Siga estes passos:\n\n1. Acesse [Discord Developer Portal](https://discord.com/developers/applications/)\n2. Selecione sua aplicação (bot)\n3. Vá em **Bot** no menu lateral\n4. Role até **Privileged Gateway Intents**\n5. Habilite as seguintes opções:\n   - ✅ **Presence Intent**\n   - ✅ **Server Members Intent**\n   - ✅ **Message Content Intent**\n6. Clique em **Save Changes**\n\n### 2. Convidar o Bot\n\nUse este link para convidar o bot (substitua `YOUR_CLIENT_ID` pelo ID da sua aplicação):\n\n```\nhttps://discord.com/api/oauth2/authorize?client_id=YOUR_CLIENT_ID&permissions=8&scope=bot%20applications.commands\n```\n\n### 3. Garantir Permissões de Administrador\n\nO sistema identifica mediadores através de permissões de **Administrador** no Discord. Certifique-se de que os membros que devem mediar apostas tenham esse cargo.\n\n## 📖 Comandos Disponíveis\n\n### 👥 Comandos para Jogadores\n\n- `/entrar-fila` - Entrar na fila de apostas\n- `/sair-fila` - Sair da fila de apostas\n- `/ver-filas` - Ver status das filas\n- `/confirmar-pagamento` - Confirmar que enviou o pagamento\n- `/minhas-apostas` - Ver suas apostas ativas\n- `/historico` - Ver histórico de apostas\n- `/ajuda` - Ver todos os comandos\n\n### 👨‍⚖️ Comandos para Mediadores\n\n- `/finalizar-aposta` - Finalizar aposta e declarar vencedor\n- `/cancelar-aposta` - Cancelar uma aposta\n\n## 🎯 Como Funciona\n\n1. **Jogador entra na fila:**\n   - Use `/entrar-fila` e escolha o modo\n   - Aguarde outro jogador\n\n2. **Canal privado é criado:**\n   - Quando 2 jogadores estão na fila, um canal privado é criado\n   - Mensagem é enviada marcando os Administradores\n   - Aparece um botão verde \"👨‍⚖️ Aceitar Mediação\"\n\n3. **ADM aceita mediar:**\n   - Primeiro ADM que clicar no botão vira o mediador\n   - Abre um formulário para ele inserir a chave PIX dele\n   - Sistema automaticamente bloqueia outros ADMs de aceitar\n   - Jogadores são notificados que um mediador aceitou\n\n4. **Confirmação de pagamento:**\n   - Ambos jogadores enviam o valor da aposta para o PIX do mediador\n   - Cada um usa `/confirmar-pagamento` no canal privado\n   - Mediador recebe notificação a cada confirmação\n\n5. **Partida:**\n   - Quando ambos confirmarem, a partida pode começar\n   - Jogadores jogam a partida\n\n6. **Finalização:**\n   - Mediador usa `/finalizar-aposta @vencedor` para declarar o vencedor\n   - Canal é automaticamente deletado após 30 segundos\n\n## 📁 Estrutura do Projeto\n\n```\n.\n├── main.py                 # Arquivo principal do bot\n├── models/\n│   ├── __init__.py\n│   └── bet.py             # Modelo de dados das apostas\n├── utils/\n│   ├── __init__.py\n│   └── database.py        # Gerenciamento de dados (JSON)\n└── data/\n    └── bets.json          # Armazenamento de apostas (criado automaticamente)\n```\n\n## 💾 Armazenamento de Dados\n\nOs dados são armazenados em `data/bets.json` e incluem:\n\n- **Filas ativas:** Jogadores aguardando em cada modo\n- **Apostas ativas:** Apostas em andamento\n- **Histórico:** Todas as apostas finalizadas\n\n## ⚠️ Problemas Comuns\n\n### Bot não responde aos comandos\n\n1. Verifique se habilitou os intents privilegiados\n2. Certifique-se de que o bot tem permissões de administrador no servidor\n3. Aguarde alguns minutos após habilitar os intents\n\n### Comandos não aparecem\n\n1. Aguarde alguns minutos após adicionar o bot\n2. Reinicie o Discord\n3. Verifique se o bot está online\n\n### Erro de permissões ao criar canais\n\nO bot precisa de permissão de administrador ou pelo menos:\n- Gerenciar Canais\n- Criar Convites\n- Enviar Mensagens\n- Mencionar Todos\n\n## 🔧 Personalização\n\nVocê pode personalizar:\n\n1. **Modos de jogo:** Edite a lista `MODES` em `main.py`\n2. **PIX do mediador:** Altere `MEDIATOR_PIX` em `main.py`\n3. **Nome da categoria:** Altere `ACTIVE_BETS_CATEGORY` em `main.py`\n4. **Tempo de deleção:** Altere o valor em `await asyncio.sleep(30)`\n\n## 📝 Logs\n\nO bot registra todas as atividades:\n- Jogadores que entraram/saíram de filas\n- Apostas criadas\n- Confirmações de pagamento\n- Apostas finalizadas\n- Vencedores\n\n## 🆘 Suporte\n\nSe tiver problemas:\n\n1. Verifique os logs do bot no console\n2. Confirme que o TOKEN está configurado corretamente\n3. Certifique-se de que os intents estão habilitados\n4. Verifique as permissões do bot no servidor\n\n## 📄 Licença\n\nEste bot foi criado para uso pessoal/privado.\n","size_bytes":5506},"nz-apostas/models/__init__.py":{"content":"","size_bytes":0},"nz-apostas/replit.md":{"content":"# NZ Apostado - Discord Betting Bot\n\n## Overview\n\nNZ Apostado is a Discord bot that manages a betting system with queue management, automated private channel creation, and bet mediation. The bot allows users to join betting queues for different game modes (1v1 Mixed, 1v1 Mob, 2v2 Mixed), automatically matches players, creates private channels for matched bets, handles payment confirmations, and manages bet finalization through mediators.\n\nThe system is built using Python with the discord.py library and implements a file-based JSON storage solution for managing queues, active bets, and bet history.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Application Structure\n\n**Problem:** Need to organize a Discord bot with betting logic, data persistence, and command handling.\n\n**Solution:** Modular architecture separating concerns:\n- `main.py` - Bot initialization, Discord event handlers, and slash commands\n- `models/bet.py` - Data model for bet representation\n- `utils/database.py` - Data persistence layer with JSON file storage\n- `data/bets.json` - Persistent storage for queues, active bets, and history\n\n**Rationale:** This separation allows independent development and testing of business logic, data models, and Discord integration. The dataclass-based Bet model provides type safety and clear data structure.\n\n### Bot Framework\n\n**Problem:** Need to interact with Discord API and handle user commands.\n\n**Solution:** Discord.py library with slash commands (app_commands) for modern Discord UX.\n\n**Key decisions:**\n- Uses `discord.ext.commands.Bot` as the base bot class\n- Implements Discord Intents for message content, member data, and guild access\n- Uses slash commands (`@bot.tree.command`) instead of traditional prefix commands for better discoverability\n\n**Alternatives considered:** Traditional prefix commands (e.g., `!command`) were available but slash commands provide better user experience and autocomplete functionality.\n\n### Data Persistence\n\n**Problem:** Need to persist betting queues, active bets, and historical data across bot restarts.\n\n**Solution:** JSON file-based storage with a database abstraction layer (`Database` class).\n\n**Structure:**\n```json\n{\n  \"queues\": {},           // Mode-specific player queues\n  \"active_bets\": {},      // Currently ongoing bets\n  \"bet_history\": []       // Completed bet records\n}\n```\n\n**Pros:**\n- Simple setup with no external database dependencies\n- Human-readable format for debugging\n- Easy to version control and backup\n\n**Cons:**\n- Not suitable for high-concurrency scenarios\n- Limited query capabilities\n- Potential data loss if file corruption occurs\n\n**Alternatives considered:** SQL databases (SQLite, PostgreSQL) would provide better concurrency and query capabilities but add complexity for this use case.\n\n### Bet Lifecycle Management\n\n**Problem:** Manage complex state transitions for bets from queue → matching → confirmation → completion.\n\n**Solution:** State machine pattern using the `Bet` dataclass with boolean flags for confirmation states.\n\n**States tracked:**\n- Queue membership (managed by Database)\n- Active bet creation (player pairing)\n- Payment confirmations (`player1_confirmed`, `player2_confirmed`)\n- Winner declaration (`winner_id`)\n- Timestamps (`created_at`, `finished_at`)\n\n**Anti-duplication mechanism:** `is_user_in_active_bet()` method prevents users from joining multiple bets simultaneously.\n\n### Channel Management\n\n**Problem:** Create private, temporary channels for matched betting pairs.\n\n**Solution:** Automatic channel creation under \"💰・Apostas Ativas\" category with permission-based access control.\n\n**Access control:**\n- Only matched players can view/interact\n- Mediator has full access\n- Bot has management permissions\n- Channel auto-deletion after bet completion (30-second delay)\n\n### Command Interface\n\n**Problem:** Provide user-friendly betting commands.\n\n**Solution:** Discord slash commands with choices for game modes.\n\n**Implemented commands:**\n- `/entrar-fila` - Join betting queue with mode selection\n- `/sair-fila` - Leave betting queue\n- `/ver-filas` - View queue status\n- `/confirmar-pagamento` - Confirm payment sent to mediator\n- `/finalizar-aposta` - [Mediator only] Finalize bet and declare winner\n- `/cancelar-aposta` - [Mediator only] Cancel ongoing bet\n- `/historico` - View bet history\n- `/minhas-apostas` - View your active bets\n- `/ajuda` - View all available commands\n\n**Choice pattern:** Uses `app_commands.Choice` to provide predefined options, preventing invalid mode inputs.\n\n### Race Condition Prevention\n\n**Problem:** Concurrent queue matches could create duplicate active bets for the same player.\n\n**Solution:** Provisional bet reservation system.\n\n**Implementation:**\n1. Before any async Discord API calls, create a provisional active bet (blocks concurrent matches)\n2. Remove players from ALL queues (not just current mode)\n3. On success: replace provisional bet with real bet\n4. On failure: remove provisional bet and re-queue players\n\nThis ensures atomic player reservation and prevents race conditions in high-traffic scenarios.\n\n### Mediator Selection\n\n**Problem:** Ensure mediator is always independent from matched players.\n\n**Solution:** Strict filtering and validation.\n\n**Implementation:**\n- Filter guild members to exclude bots AND both players\n- If no valid mediators available: abort creation and re-queue players\n- Never allows a player to be their own mediator, even in small guilds\n\n## Recent Changes (October 23, 2025)\n\n### Complete Bot Implementation\n- Implemented full betting system with queue management\n- Added private channel creation with access control\n- Payment confirmation system with mediator notifications\n- Bet finalization with automatic channel cleanup\n- Comprehensive logging and history tracking\n\n### Critical Bug Fixes\n- Fixed race condition allowing duplicate active bets\n- Fixed mediator selection to prevent players being their own mediator\n- Added provisional bet system for atomic player reservation\n- Added queue restoration on failed bet creation\n\n### Configuration Management\n\n**Problem:** Store sensitive data like bot tokens and PIX keys.\n\n**Solution:** Environment variables for secrets, constants for static configuration.\n\n- Bot token: Environment variable `TOKEN` (referenced in README)\n- PIX key: Hardcoded constant `MEDIATOR_PIX` (should be environment variable)\n- Game modes: Python list constant `MODES`\n\n## External Dependencies\n\n### Discord.py Library\n\n**Purpose:** Primary framework for Discord bot functionality.\n\n**Features used:**\n- `discord.ext.commands` - Bot command framework\n- `discord.app_commands` - Slash command implementation\n- `discord.Intents` - Gateway intents for accessing Discord events\n- Discord object models (User, Channel, Guild, etc.)\n\n**Required intents:**\n- Message Content Intent (privileged)\n- Server Members Intent (privileged)\n- Presence Intent (privileged)\n\n### Python Standard Library\n\n**Dependencies:**\n- `json` - Data serialization/deserialization\n- `os` - File system operations and environment variables\n- `datetime` - Timestamp generation\n- `random` - Likely used for mediator selection or bet ID generation\n- `dataclasses` - Type-safe data models\n- `typing` - Type hints for better code documentation\n\n### Discord Developer Portal\n\n**Purpose:** Bot registration and permission management.\n\n**Configuration required:**\n- Application/bot creation\n- Privileged gateway intents enablement\n- OAuth2 URL generation for bot invitation\n- Bot token generation\n\n### File System\n\n**Purpose:** Persistent storage backend.\n\n**Requirements:**\n- Read/write access to `data/` directory\n- JSON file persistence (`data/bets.json`)\n\n**Note:** The current implementation uses JSON file storage, but the architecture would support migration to a relational database (e.g., PostgreSQL) if needed for scalability.","size_bytes":7910},"nz-apostas/main.py":{"content":"import os\nimport discord\nfrom discord import app_commands\nfrom discord.ext import commands\nimport random\nfrom datetime import datetime\nfrom models.bet import Bet\nfrom utils.database import Database\n\n# Detectar se está rodando no Railway\nIS_RAILWAY = os.getenv(\"RAILWAY_ENVIRONMENT\") is not None or os.getenv(\"RAILWAY_STATIC_URL\") is not None\n\nif IS_RAILWAY:\n    print(\"🚂 Detectado ambiente Railway\")\nelse:\n    print(\"💻 Detectado ambiente Replit/Local\")\n\nintents = discord.Intents.default()\nintents.message_content = True\nintents.members = True\nintents.guilds = True\n\nbot = commands.Bot(command_prefix=\"!\", intents=intents)\ndb = Database()\n\nMODES = [\"1v1-misto\", \"1v1-mob\", \"2v2-misto\"]\nACTIVE_BETS_CATEGORY = \"💰 Apostas Ativas\"\nEMBED_COLOR = 0x5865F2\n\n\nclass QueueButton(discord.ui.View):\n    def __init__(self, mode: str, bet_value: float, mediator_fee: float, message_id: int = None):\n        super().__init__(timeout=None)\n        self.mode = mode\n        self.bet_value = bet_value\n        self.mediator_fee = mediator_fee\n        self.message_id = message_id\n        self.queue_id = f\"{mode}_{message_id}\" if message_id else \"\"\n        self.is_2v2 = \"2v2\" in mode\n\n        # Remove o botão \"Entrar na Fila\" se for 2v2\n        if self.is_2v2:\n            self.remove_item(self.join_queue_button)\n        else:\n            # Remove os botões de time se for 1v1\n            self.remove_item(self.join_team1_button)\n            self.remove_item(self.join_team2_button)\n\n    async def update_queue_message(self, interaction: discord.Interaction):\n        \"\"\"Atualiza a mensagem da fila com os jogadores atuais\"\"\"\n        if not self.message_id:\n            return\n\n        try:\n            message = await interaction.channel.fetch_message(self.message_id)\n\n            if self.is_2v2:\n                team1_queue = db.get_queue(f\"{self.queue_id}_team1\")\n                team2_queue = db.get_queue(f\"{self.queue_id}_team2\")\n\n                # Time 1\n                team1_names = []\n                for user_id in team1_queue:\n                    try:\n                        member = await interaction.guild.fetch_member(user_id)\n                        team1_names.append(member.mention)\n                    except:\n                        team1_names.append(f\"<@{user_id}>\")\n\n                # Time 2\n                team2_names = []\n                for user_id in team2_queue:\n                    try:\n                        member = await interaction.guild.fetch_member(user_id)\n                        team2_names.append(member.mention)\n                    except:\n                        team2_names.append(f\"<@{user_id}>\")\n\n                team1_text = \"\\n\".join(team1_names) if team1_names else \"Nenhum jogador\"\n                team2_text = \"\\n\".join(team2_names) if team2_names else \"Nenhum jogador\"\n\n                embed = discord.Embed(\n                    title=self.mode.replace('-', ' ').title(),\n                    color=EMBED_COLOR\n                )\n\n                embed.add_field(name=\"Valor\", value=f\"R$ {self.bet_value:.2f}\".replace('.', ','), inline=True)\n                embed.add_field(name=\"Time 1\", value=team1_text, inline=True)\n                embed.add_field(name=\"Time 2\", value=team2_text, inline=True)\n                if interaction.guild.icon:\n                    embed.set_thumbnail(url=interaction.guild.icon.url)\n            else:\n                queue = db.get_queue(self.queue_id)\n\n                # Busca os nomes dos jogadores na fila\n                player_names = []\n                for user_id in queue:\n                    try:\n                        member = await interaction.guild.fetch_member(user_id)\n                        player_names.append(member.mention)\n                    except:\n                        player_names.append(f\"<@{user_id}>\")\n\n                players_text = \"\\n\".join(player_names) if player_names else \"Nenhum jogador na fila\"\n\n                embed = discord.Embed(\n                    title=self.mode.replace('-', ' ').title(),\n                    color=EMBED_COLOR\n                )\n\n                embed.add_field(name=\"Valor\", value=f\"R$ {self.bet_value:.2f}\".replace('.', ','), inline=True)\n                embed.add_field(name=\"Fila\", value=players_text if players_text != \"Nenhum jogador na fila\" else \"Vazio\", inline=True)\n                if interaction.guild.icon:\n                    embed.set_thumbnail(url=interaction.guild.icon.url)\n\n            await message.edit(embed=embed)\n        except:\n            pass\n\n    @discord.ui.button(label='Entrar na Fila', style=discord.ButtonStyle.blurple, row=0)\n    async def join_queue_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        # Este botão não aparece no modo 2v2\n        if self.is_2v2:\n            return\n\n        user_id = interaction.user.id\n\n        if db.is_user_in_active_bet(user_id):\n            await interaction.response.send_message(\n                \"Você já está em uma aposta ativa. Finalize ela antes de entrar em outra fila.\",\n                ephemeral=True\n            )\n            return\n\n        queue = db.get_queue(self.queue_id)\n\n        if user_id in queue:\n            await interaction.response.send_message(\n                \"Você já está nesta fila.\",\n                ephemeral=True\n            )\n            return\n\n        db.add_to_queue(self.queue_id, user_id)\n        queue = db.get_queue(self.queue_id)\n\n        embed = discord.Embed(\n            title=\"✅ Entrou na fila\",\n            description=f\"{self.mode.replace('-', ' ').title()} - {len(queue)}/2\",\n            color=EMBED_COLOR\n        )\n        if interaction.guild.icon:\n            embed.set_thumbnail(url=interaction.guild.icon.url)\n\n        await interaction.response.send_message(embed=embed, ephemeral=True)\n\n        # Atualiza a mensagem principal\n        await self.update_queue_message(interaction)\n\n        if len(queue) >= 2:\n            player1_id = queue[0]\n            player2_id = queue[1]\n\n            db.remove_from_queue(self.queue_id, player1_id)\n            db.remove_from_queue(self.queue_id, player2_id)\n\n            # Atualiza a mensagem após remover os jogadores\n            await self.update_queue_message(interaction)\n\n            await create_bet_channel(interaction.guild, self.mode, player1_id, player2_id, self.bet_value, self.mediator_fee)\n\n    @discord.ui.button(label='Sair da Fila', style=discord.ButtonStyle.gray, row=0)\n    async def leave_queue_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        user_id = interaction.user.id\n\n        if self.is_2v2:\n            team1_queue_id = f\"{self.queue_id}_team1\"\n            team2_queue_id = f\"{self.queue_id}_team2\"\n\n            team1_queue = db.get_queue(team1_queue_id)\n            team2_queue = db.get_queue(team2_queue_id)\n\n            if user_id in team1_queue:\n                db.remove_from_queue(team1_queue_id, user_id)\n                embed = discord.Embed(\n                    title=\"❌ Saiu - Time 1\",\n                    color=EMBED_COLOR\n                )\n                if interaction.guild.icon:\n                    embed.set_thumbnail(url=interaction.guild.icon.url)\n                await interaction.response.send_message(embed=embed, ephemeral=True)\n                await self.update_queue_message(interaction)\n                return\n            elif user_id in team2_queue:\n                db.remove_from_queue(team2_queue_id, user_id)\n                embed = discord.Embed(\n                    title=\"❌ Saiu - Time 2\",\n                    color=EMBED_COLOR\n                )\n                if interaction.guild.icon:\n                    embed.set_thumbnail(url=interaction.guild.icon.url)\n                await interaction.response.send_message(embed=embed, ephemeral=True)\n                await self.update_queue_message(interaction)\n                return\n            else:\n                await interaction.response.send_message(\n                    \"Você não está em nenhum time.\",\n                    ephemeral=True\n                )\n                return\n        else:\n            queue = db.get_queue(self.queue_id)\n\n            if user_id not in queue:\n                await interaction.response.send_message(\n                    \"Você não está nesta fila.\",\n                    ephemeral=True\n                )\n                return\n\n            db.remove_from_queue(self.queue_id, user_id)\n\n            embed = discord.Embed(\n                title=\"❌ Saiu da fila\",\n                color=EMBED_COLOR\n            )\n            if interaction.guild.icon:\n                embed.set_thumbnail(url=interaction.guild.icon.url)\n\n            await interaction.response.send_message(embed=embed, ephemeral=True)\n\n            # Atualiza a mensagem principal\n            await self.update_queue_message(interaction)\n\n    @discord.ui.button(label='Entrar no Time 1', style=discord.ButtonStyle.blurple, row=0)\n    async def join_team1_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not self.is_2v2:\n            await interaction.response.send_message(\n                \"Este botão é exclusivo do modo 2v2.\",\n                ephemeral=True\n            )\n            return\n\n        user_id = interaction.user.id\n\n        if db.is_user_in_active_bet(user_id):\n            await interaction.response.send_message(\n                \"Você já está em uma aposta ativa. Finalize ela antes de entrar em outra fila.\",\n                ephemeral=True\n            )\n            return\n\n        team1_queue_id = f\"{self.queue_id}_team1\"\n        team2_queue_id = f\"{self.queue_id}_team2\"\n\n        team1_queue = db.get_queue(team1_queue_id)\n        team2_queue = db.get_queue(team2_queue_id)\n\n        if user_id in team1_queue:\n            await interaction.response.send_message(\n                \"Você já está no Time 1.\",\n                ephemeral=True\n            )\n            return\n\n        if user_id in team2_queue:\n            await interaction.response.send_message(\n                \"Você já está no Time 2. Saia primeiro para entrar no Time 1.\",\n                ephemeral=True\n            )\n            return\n\n        if len(team1_queue) >= 2:\n            await interaction.response.send_message(\n                \"O Time 1 já está completo.\",\n                ephemeral=True\n            )\n            return\n\n        db.add_to_queue(team1_queue_id, user_id)\n        team1_queue = db.get_queue(team1_queue_id)\n\n        embed = discord.Embed(\n            title=\"✅ Time 1\",\n            description=f\"{self.mode.replace('-', ' ').title()} - {len(team1_queue)}/2\",\n            color=EMBED_COLOR\n        )\n        if interaction.guild.icon:\n            embed.set_thumbnail(url=interaction.guild.icon.url)\n\n        await interaction.response.send_message(embed=embed, ephemeral=True)\n        await self.update_queue_message(interaction)\n\n        # Verifica se ambos os times estão completos\n        team2_queue = db.get_queue(team2_queue_id)\n        if len(team1_queue) == 2 and len(team2_queue) == 2:\n            await self.create_2v2_match(interaction.guild, team1_queue, team2_queue)\n\n    @discord.ui.button(label='Entrar no Time 2', style=discord.ButtonStyle.blurple, row=0)\n    async def join_team2_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not self.is_2v2:\n            await interaction.response.send_message(\n                \"Este botão é exclusivo do modo 2v2.\",\n                ephemeral=True\n            )\n            return\n\n        user_id = interaction.user.id\n\n        if db.is_user_in_active_bet(user_id):\n            await interaction.response.send_message(\n                \"Você já está em uma aposta ativa. Finalize ela antes de entrar em outra fila.\",\n                ephemeral=True\n            )\n            return\n\n        team1_queue_id = f\"{self.queue_id}_team1\"\n        team2_queue_id = f\"{self.queue_id}_team2\"\n\n        team1_queue = db.get_queue(team1_queue_id)\n        team2_queue = db.get_queue(team2_queue_id)\n\n        if user_id in team2_queue:\n            await interaction.response.send_message(\n                \"Você já está no Time 2.\",\n                ephemeral=True\n            )\n            return\n\n        if user_id in team1_queue:\n            await interaction.response.send_message(\n                \"Você já está no Time 1. Saia primeiro para entrar no Time 2.\",\n                ephemeral=True\n            )\n            return\n\n        if len(team2_queue) >= 2:\n            await interaction.response.send_message(\n                \"O Time 2 já está completo.\",\n                ephemeral=True\n            )\n            return\n\n        db.add_to_queue(team2_queue_id, user_id)\n        team2_queue = db.get_queue(team2_queue_id)\n\n        embed = discord.Embed(\n            title=\"✅ Time 2\",\n            description=f\"{self.mode.replace('-', ' ').title()} - {len(team2_queue)}/2\",\n            color=EMBED_COLOR\n        )\n        if interaction.guild.icon:\n            embed.set_thumbnail(url=interaction.guild.icon.url)\n\n        await interaction.response.send_message(embed=embed, ephemeral=True)\n        await self.update_queue_message(interaction)\n\n        # Verifica se ambos os times estão completos\n        team1_queue = db.get_queue(team1_queue_id)\n        if len(team1_queue) == 2 and len(team2_queue) == 2:\n            await self.create_2v2_match(interaction.guild, team1_queue, team2_queue)\n\n    async def create_2v2_match(self, guild: discord.Guild, team1_queue: list, team2_queue: list):\n        \"\"\"Cria uma partida 2v2 quando ambos os times estão completos\"\"\"\n        team1_queue_id = f\"{self.queue_id}_team1\"\n        team2_queue_id = f\"{self.queue_id}_team2\"\n\n        # Remove todos os jogadores das filas\n        for user_id in team1_queue:\n            db.remove_from_queue(team1_queue_id, user_id)\n        for user_id in team2_queue:\n            db.remove_from_queue(team2_queue_id, user_id)\n\n        # Cria o canal da aposta 2v2\n        await create_2v2_bet_channel(guild, self.mode, team1_queue, team2_queue, self.bet_value, self.mediator_fee)\n\n\nclass ConfirmPaymentButton(discord.ui.View):\n    def __init__(self, bet_id: str):\n        super().__init__(timeout=None)\n        self.bet_id = bet_id\n\n    @discord.ui.button(label='Confirmar Pagamento', style=discord.ButtonStyle.green, emoji='💰')\n    async def confirm_payment_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        bet = db.get_active_bet(self.bet_id)\n\n        if not bet:\n            await interaction.response.send_message(\n                \"Esta aposta não foi encontrada.\",\n                ephemeral=True\n            )\n            return\n\n        if bet.mediator_id == 0:\n            await interaction.response.send_message(\n                \"Aguarde um mediador aceitar esta aposta antes de confirmar pagamento.\",\n                ephemeral=True\n            )\n            return\n\n        user_id = interaction.user.id\n\n        if user_id == bet.player1_id:\n            if bet.player1_confirmed:\n                await interaction.response.send_message(\n                    \"Você já confirmou seu pagamento.\",\n                    ephemeral=True\n                )\n                return\n\n            bet.player1_confirmed = True\n            db.update_active_bet(bet)\n\n            player1 = await interaction.guild.fetch_member(bet.player1_id)\n            mediator = await interaction.guild.fetch_member(bet.mediator_id)\n\n            embed = discord.Embed(\n                title=\"✅ Pagamento Confirmado\",\n                description=player1.mention,\n                color=EMBED_COLOR\n            )\n            await interaction.response.send_message(embed=embed)\n\n            try:\n                await mediator.send(f\"{player1.name} confirmou o pagamento na aposta {interaction.channel.mention}\")\n            except:\n                pass\n\n        elif user_id == bet.player2_id:\n            if bet.player2_confirmed:\n                await interaction.response.send_message(\n                    \"Você já confirmou seu pagamento.\",\n                    ephemeral=True\n                )\n                return\n\n            bet.player2_confirmed = True\n            db.update_active_bet(bet)\n\n            player2 = await interaction.guild.fetch_member(bet.player2_id)\n            mediator = await interaction.guild.fetch_member(bet.mediator_id)\n\n            embed = discord.Embed(\n                title=\"✅ Pagamento Confirmado\",\n                description=player2.mention,\n                color=EMBED_COLOR\n            )\n            await interaction.response.send_message(embed=embed)\n\n            try:\n                await mediator.send(f\"{player2.name} confirmou o pagamento na aposta {interaction.channel.mention}\")\n            except:\n                pass\n        else:\n            await interaction.response.send_message(\n                \"Você não é um dos jogadores desta aposta.\",\n                ephemeral=True\n            )\n            return\n\n        if bet.is_fully_confirmed():\n            player1 = await interaction.guild.fetch_member(bet.player1_id)\n            player2 = await interaction.guild.fetch_member(bet.player2_id)\n\n            embed = discord.Embed(\n                title=\"✅ Pagamentos Confirmados\",\n                description=\"Partida liberada\",\n                color=EMBED_COLOR\n            )\n\n            await interaction.channel.send(embed=embed)\n\n\nclass PixModal(discord.ui.Modal, title='Inserir Chave PIX'):\n    pix_key = discord.ui.TextInput(\n        label='Chave PIX',\n        placeholder='Digite sua chave PIX (CPF, telefone, email, etc)',\n        required=True,\n        max_length=100\n    )\n\n    def __init__(self, bet_id: str):\n        super().__init__()\n        self.bet_id = bet_id\n\n    async def on_submit(self, interaction: discord.Interaction):\n        bet = db.get_active_bet(self.bet_id)\n        if not bet:\n            await interaction.response.send_message(\"Aposta não encontrada.\", ephemeral=True)\n            return\n\n        if bet.mediator_id != 0:\n            mediator = await interaction.guild.fetch_member(bet.mediator_id)\n            await interaction.response.send_message(\n                f\"Esta aposta já tem um mediador: {mediator.mention}\",\n                ephemeral=True\n            )\n            return\n\n        bet.mediator_id = interaction.user.id\n        bet.mediator_pix = str(self.pix_key.value)\n        db.update_active_bet(bet)\n\n        player1 = await interaction.guild.fetch_member(bet.player1_id)\n        player2 = await interaction.guild.fetch_member(bet.player2_id)\n\n        embed = discord.Embed(\n            title=\"Mediador Aceito\",\n            color=EMBED_COLOR\n        )\n        embed.add_field(name=\"Modo\", value=bet.mode.replace(\"-\", \" \").title(), inline=True)\n        embed.add_field(name=\"Jogadores\", value=f\"{player1.mention} vs {player2.mention}\", inline=False)\n        embed.add_field(name=\"Mediador\", value=interaction.user.mention, inline=True)\n        embed.add_field(name=\"PIX\", value=f\"`{bet.mediator_pix}`\", inline=True)\n        embed.add_field(name=\"Instrução\", value=\"Envie o pagamento e clique no botão abaixo para confirmar\", inline=False)\n        if interaction.guild.icon:\n            embed.set_thumbnail(url=interaction.guild.icon.url)\n\n        confirm_view = ConfirmPaymentButton(self.bet_id)\n        await interaction.response.send_message(embed=embed, view=confirm_view)\n\n        try:\n            original_message = await interaction.channel.fetch_message(interaction.message.id)\n            await original_message.edit(view=None)\n        except:\n            pass\n\n        channel = interaction.guild.get_channel(bet.channel_id)\n        if channel:\n            perms = channel.overwrites_for(interaction.user)\n            perms.read_messages = True\n            perms.send_messages = True\n            await channel.set_permissions(interaction.user, overwrite=perms)\n\n        try:\n            await player1.send(f\"Um mediador aceitou sua aposta. Acesse {channel.mention}\")\n        except:\n            pass\n\n        try:\n            await player2.send(f\"Um mediador aceitou sua aposta. Acesse {channel.mention}\")\n        except:\n            pass\n\n\nclass AcceptMediationButton(discord.ui.View):\n    def __init__(self, bet_id: str):\n        super().__init__(timeout=None)\n        self.bet_id = bet_id\n\n    @discord.ui.button(label='Aceitar Mediação', style=discord.ButtonStyle.green)\n    async def accept_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        bet = db.get_active_bet(self.bet_id)\n\n        if not bet:\n            await interaction.response.send_message(\"Aposta não encontrada.\", ephemeral=True)\n            return\n\n        if bet.mediator_id != 0:\n            await interaction.response.send_message(\"Esta aposta já tem um mediador.\", ephemeral=True)\n            return\n\n        if not interaction.user.guild_permissions.administrator:\n            await interaction.response.send_message(\"Apenas administradores podem aceitar mediação.\", ephemeral=True)\n            return\n\n        await interaction.response.send_modal(PixModal(self.bet_id))\n\n\n@bot.event\nasync def on_ready():\n    print(f'Bot conectado como {bot.user}')\n    print(f'Nome: {bot.user.name}')\n    print(f'ID: {bot.user.id}')\n    try:\n        synced = await bot.tree.sync()\n        print(f'{len(synced)} comandos sincronizados')\n    except Exception as e:\n        print(f'Erro ao sincronizar comandos: {e}')\n\n\n\n\n\n@bot.tree.command(name=\"mostrar-fila\", description=\"[MODERADOR] Criar mensagem com botão para entrar na fila\")\n@app_commands.describe(\n    modo=\"Escolha o modo de jogo\",\n    valor=\"Valor da aposta (exemplo: 5.00)\",\n    taxa=\"Taxa do mediador (exemplo: 0.50)\"\n)\n@app_commands.choices(modo=[\n    app_commands.Choice(name=\"1v1 Misto\", value=\"1v1-misto\"),\n    app_commands.Choice(name=\"1v1 Mob\", value=\"1v1-mob\"),\n    app_commands.Choice(name=\"2v2 Misto\", value=\"2v2-misto\"),\n])\nasync def mostrar_fila(interaction: discord.Interaction, modo: app_commands.Choice[str], valor: float, taxa: float):\n    if not interaction.user.guild_permissions.administrator:\n        await interaction.response.send_message(\n            \"Apenas moderadores podem usar este comando.\",\n            ephemeral=True\n        )\n        return\n\n    mode = modo.value\n\n    embed = discord.Embed(\n        title=modo.name,\n        color=EMBED_COLOR\n    )\n\n    embed.add_field(name=\"Valor\", value=f\"R$ {valor:.2f}\".replace('.', ','), inline=True)\n    embed.add_field(name=\"Fila\", value=\"Vazio\", inline=True)\n    if interaction.guild.icon:\n        embed.set_thumbnail(url=interaction.guild.icon.url)\n\n    await interaction.response.send_message(embed=embed)\n\n    # Pega a mensagem enviada para passar o ID para o botão\n    message = await interaction.original_response()\n    view = QueueButton(mode, valor, taxa, message.id)\n\n    await message.edit(embed=embed, view=view)\n\n\n\n\n\n\n\n\nasync def create_2v2_bet_channel(guild: discord.Guild, mode: str, team1: list, team2: list, bet_value: float, mediator_fee: float):\n    \"\"\"Cria um canal de aposta para modo 2v2\"\"\"\n    # Verifica se algum jogador já está em aposta ativa\n    for user_id in team1 + team2:\n        if db.is_user_in_active_bet(user_id):\n            print(f\"Jogador {user_id} já está em uma aposta ativa. Abortando criação.\")\n            return\n\n    # Remove todos os jogadores de todas as filas\n    for user_id in team1 + team2:\n        db.remove_from_all_queues(user_id)\n\n    try:\n        # Busca os membros\n        team1_members = []\n        team2_members = []\n\n        for user_id in team1:\n            member = await guild.fetch_member(user_id)\n            team1_members.append(member)\n\n        for user_id in team2:\n            member = await guild.fetch_member(user_id)\n            team2_members.append(member)\n\n        category = discord.utils.get(guild.categories, name=ACTIVE_BETS_CATEGORY)\n        if not category:\n            category = await guild.create_category(ACTIVE_BETS_CATEGORY)\n\n        channel_name = f\"aposta-2v2-{team1_members[0].name}-{team1_members[1].name}-vs-{team2_members[0].name}-{team2_members[1].name}\"\n\n        overwrites = {\n            guild.default_role: discord.PermissionOverwrite(read_messages=False),\n            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)\n        }\n\n        # Adiciona permissões para todos os jogadores\n        for member in team1_members + team2_members:\n            overwrites[member] = discord.PermissionOverwrite(read_messages=True, send_messages=True)\n\n        channel = await category.create_text_channel(name=channel_name, overwrites=overwrites)\n\n        # Cria ID da aposta com todos os jogadores\n        bet_id = f\"2v2_{team1[0]}_{team1[1]}_{team2[0]}_{team2[1]}_{int(datetime.now().timestamp())}\"\n\n        # Para 2v2, armazena como string separada por vírgula\n        bet = Bet(\n            bet_id=bet_id,\n            mode=mode,\n            player1_id=team1[0],  # Líder do time 1\n            player2_id=team2[0],  # Líder do time 2\n            mediator_id=0,\n            channel_id=channel.id,\n            bet_value=bet_value,\n            mediator_fee=mediator_fee\n        )\n\n        # Adiciona campos customizados para 2v2\n        bet_dict = bet.to_dict()\n        bet_dict['team1'] = team1\n        bet_dict['team2'] = team2\n        bet_dict['is_2v2'] = True\n\n        # Salva manualmente com campos extras\n        data = db._load_data()\n        data['active_bets'][bet_id] = bet_dict\n        db._save_data(data)\n\n    except Exception as e:\n        print(f\"Erro ao criar canal de aposta 2v2: {e}\")\n        return\n\n    admin_role = discord.utils.get(guild.roles, permissions=discord.Permissions(administrator=True))\n    admin_mention = admin_role.mention if admin_role else \"@Administradores\"\n\n    team1_mentions = \" \".join([m.mention for m in team1_members])\n    team2_mentions = \" \".join([m.mention for m in team2_members])\n\n    embed = discord.Embed(\n        title=\"Aposta 2v2 - Aguardando Mediador\",\n        description=admin_mention,\n        color=EMBED_COLOR\n    )\n    embed.add_field(name=\"Modo\", value=mode.replace(\"-\", \" \").title(), inline=True)\n    embed.add_field(name=\"Valor/jogador\", value=f\"R$ {bet_value:.2f}\".replace('.', ','), inline=True)\n    embed.add_field(name=\"Taxa\", value=f\"R$ {mediator_fee:.2f}\".replace('.', ','), inline=True)\n    embed.add_field(name=\"Time 1\", value=team1_mentions, inline=True)\n    embed.add_field(name=\"Time 2\", value=team2_mentions, inline=True)\n    if guild.icon:\n        embed.set_thumbnail(url=guild.icon.url)\n\n    view = AcceptMediationButton(bet_id)\n\n    all_mentions = \" \".join([m.mention for m in team1_members + team2_members])\n    await channel.send(content=f\"{all_mentions} {admin_mention}\", embed=embed, view=view)\n\n    # Notifica todos os jogadores\n    for member in team1_members + team2_members:\n        try:\n            await member.send(f\"Sua aposta 2v2 foi criada. Aguardando mediador. Acesse {channel.mention}\")\n        except:\n            pass\n\n\nasync def create_bet_channel(guild: discord.Guild, mode: str, player1_id: int, player2_id: int, bet_value: float, mediator_fee: float):\n    if db.is_user_in_active_bet(player1_id) or db.is_user_in_active_bet(player2_id):\n        print(f\"Um dos jogadores já está em uma aposta ativa. Abortando criação.\")\n        return\n\n    db.remove_from_all_queues(player1_id)\n    db.remove_from_all_queues(player2_id)\n\n    try:\n        player1 = await guild.fetch_member(player1_id)\n        player2 = await guild.fetch_member(player2_id)\n\n        category = discord.utils.get(guild.categories, name=ACTIVE_BETS_CATEGORY)\n        if not category:\n            category = await guild.create_category(ACTIVE_BETS_CATEGORY)\n\n        channel_name = f\"aposta-{player1.name}-vs-{player2.name}\"\n\n        overwrites = {\n            guild.default_role: discord.PermissionOverwrite(read_messages=False),\n            player1: discord.PermissionOverwrite(read_messages=True, send_messages=True),\n            player2: discord.PermissionOverwrite(read_messages=True, send_messages=True),\n            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)\n        }\n\n        channel = await category.create_text_channel(name=channel_name, overwrites=overwrites)\n\n        bet_id = f\"{player1_id}_{player2_id}_{int(datetime.now().timestamp())}\"\n        bet = Bet(\n            bet_id=bet_id,\n            mode=mode,\n            player1_id=player1_id,\n            player2_id=player2_id,\n            mediator_id=0,\n            channel_id=channel.id,\n            bet_value=bet_value,\n            mediator_fee=mediator_fee\n        )\n        db.add_active_bet(bet)\n    except Exception as e:\n        print(f\"Erro ao criar canal de aposta: {e}\")\n        db.add_to_queue(mode, player1_id)\n        db.add_to_queue(mode, player2_id)\n        return\n\n    admin_role = discord.utils.get(guild.roles, permissions=discord.Permissions(administrator=True))\n    admin_mention = admin_role.mention if admin_role else \"@Administradores\"\n\n    embed = discord.Embed(\n        title=\"Aposta - Aguardando Mediador\",\n        description=admin_mention,\n        color=EMBED_COLOR\n    )\n    embed.add_field(name=\"Modo\", value=mode.replace(\"-\", \" \").title(), inline=True)\n    embed.add_field(name=\"Valor\", value=f\"R$ {bet_value:.2f}\".replace('.', ','), inline=True)\n    embed.add_field(name=\"Taxa\", value=f\"R$ {mediator_fee:.2f}\".replace('.', ','), inline=True)\n    embed.add_field(name=\"Jogadores\", value=f\"{player1.mention} vs {player2.mention}\", inline=False)\n    if guild.icon:\n        embed.set_thumbnail(url=guild.icon.url)\n\n    view = AcceptMediationButton(bet_id)\n\n    await channel.send(content=f\"{player1.mention} {player2.mention} {admin_mention}\", embed=embed, view=view)\n\n    try:\n        await player1.send(f\"Sua aposta foi criada. Aguardando mediador. Acesse {channel.mention}\")\n    except:\n        pass\n\n    try:\n        await player2.send(f\"Sua aposta foi criada. Aguardando mediador. Acesse {channel.mention}\")\n    except:\n        pass\n\n\n@bot.tree.command(name=\"confirmar-pagamento\", description=\"Confirmar que você enviou o pagamento ao mediador\")\nasync def confirmar_pagamento(interaction: discord.Interaction):\n    bet = db.get_bet_by_channel(interaction.channel_id)\n\n    if not bet:\n        await interaction.response.send_message(\n            \"Este canal não é uma aposta ativa.\",\n            ephemeral=True\n        )\n        return\n\n    if bet.mediator_id == 0:\n        await interaction.response.send_message(\n            \"Aguarde um mediador aceitar esta aposta antes de confirmar pagamento.\",\n            ephemeral=True\n        )\n        return\n\n    user_id = interaction.user.id\n\n    if user_id == bet.player1_id:\n        if bet.player1_confirmed:\n            await interaction.response.send_message(\n                \"Você já confirmou seu pagamento.\",\n                ephemeral=True\n            )\n            return\n\n        bet.player1_confirmed = True\n        db.update_active_bet(bet)\n\n        player1 = await interaction.guild.fetch_member(bet.player1_id)\n        mediator = await interaction.guild.fetch_member(bet.mediator_id)\n\n        embed = discord.Embed(\n            title=\"✅ Pagamento Confirmado\",\n            description=player1.mention,\n            color=EMBED_COLOR\n        )\n        await interaction.response.send_message(embed=embed)\n\n        try:\n            await mediator.send(f\"{player1.name} confirmou o pagamento na aposta {interaction.channel.mention}\")\n        except:\n            pass\n\n    elif user_id == bet.player2_id:\n        if bet.player2_confirmed:\n            await interaction.response.send_message(\n                \"Você já confirmou seu pagamento.\",\n                ephemeral=True\n            )\n            return\n\n        bet.player2_confirmed = True\n        db.update_active_bet(bet)\n\n        player2 = await interaction.guild.fetch_member(bet.player2_id)\n        mediator = await interaction.guild.fetch_member(bet.mediator_id)\n\n        embed = discord.Embed(\n            title=\"✅ Pagamento Confirmado\",\n            description=player2.mention,\n            color=EMBED_COLOR\n        )\n        await interaction.response.send_message(embed=embed)\n\n        try:\n            await mediator.send(f\"{player2.name} confirmou o pagamento na aposta {interaction.channel.mention}\")\n        except:\n            pass\n    else:\n        await interaction.response.send_message(\n            \"Você não é um dos jogadores desta aposta.\",\n            ephemeral=True\n        )\n        return\n\n    if bet.is_fully_confirmed():\n        player1 = await interaction.guild.fetch_member(bet.player1_id)\n        player2 = await interaction.guild.fetch_member(bet.player2_id)\n\n        embed = discord.Embed(\n            title=\"✅ Pagamentos Confirmados\",\n            description=\"Partida liberada\",\n            color=EMBED_COLOR\n        )\n\n        await interaction.channel.send(embed=embed)\n\n\n@bot.tree.command(name=\"finalizar-aposta\", description=\"[MEDIADOR] Finalizar a aposta e declarar vencedor\")\n@app_commands.describe(vencedor=\"Mencione o jogador vencedor\")\nasync def finalizar_aposta(interaction: discord.Interaction, vencedor: discord.Member):\n    bet = db.get_bet_by_channel(interaction.channel_id)\n\n    if not bet:\n        await interaction.response.send_message(\n            \"Este canal não é uma aposta ativa.\",\n            ephemeral=True\n        )\n        return\n\n    if interaction.user.id != bet.mediator_id:\n        await interaction.response.send_message(\n            \"Apenas o mediador pode finalizar esta aposta.\",\n            ephemeral=True\n        )\n        return\n\n    if vencedor.id not in [bet.player1_id, bet.player2_id]:\n        await interaction.response.send_message(\n            \"O vencedor deve ser um dos jogadores desta aposta.\",\n            ephemeral=True\n        )\n        return\n\n    bet.winner_id = vencedor.id\n    bet.finished_at = datetime.now().isoformat()\n\n    player1 = await interaction.guild.fetch_member(bet.player1_id)\n    player2 = await interaction.guild.fetch_member(bet.player2_id)\n    loser = player1 if vencedor.id == bet.player2_id else player2\n\n    embed = discord.Embed(\n        title=\"🏆 Vencedor\",\n        description=vencedor.mention,\n        color=EMBED_COLOR\n    )\n    embed.add_field(name=\"Modo\", value=bet.mode.replace(\"-\", \" \").title(), inline=True)\n    embed.add_field(name=\"Perdedor\", value=loser.mention, inline=True)\n\n    await interaction.response.send_message(embed=embed)\n\n    db.finish_bet(bet)\n\n    import asyncio\n    await asyncio.sleep(10)\n\n    try:\n        await interaction.channel.delete()\n    except:\n        pass\n\n\n@bot.tree.command(name=\"cancelar-aposta\", description=\"[MEDIADOR] Cancelar uma aposta em andamento\")\nasync def cancelar_aposta(interaction: discord.Interaction):\n    bet = db.get_bet_by_channel(interaction.channel_id)\n\n    if not bet:\n        await interaction.response.send_message(\n            \"Este canal não é uma aposta ativa.\",\n            ephemeral=True\n        )\n        return\n\n    if interaction.user.id != bet.mediator_id:\n        await interaction.response.send_message(\n            \"Apenas o mediador pode cancelar esta aposta.\",\n            ephemeral=True\n        )\n        return\n\n    player1 = await interaction.guild.fetch_member(bet.player1_id)\n    player2 = await interaction.guild.fetch_member(bet.player2_id)\n\n    embed = discord.Embed(\n        title=\"❌ Aposta Cancelada\",\n        description=f\"{player1.mention} e {player2.mention}\",\n        color=EMBED_COLOR\n    )\n\n    await interaction.response.send_message(embed=embed)\n\n    bet.finished_at = datetime.now().isoformat()\n    db.finish_bet(bet)\n\n    import asyncio\n    await asyncio.sleep(10)\n\n    try:\n        await interaction.channel.delete()\n    except:\n        pass\n\n\n@bot.tree.command(name=\"historico\", description=\"Ver o histórico de apostas\")\nasync def historico(interaction: discord.Interaction):\n    history = db.get_bet_history()\n\n    if not history:\n        await interaction.response.send_message(\n            \"Ainda não há histórico de apostas.\",\n            ephemeral=True\n        )\n        return\n\n    embed = discord.Embed(\n        title=\"Histórico de Apostas\",\n        description=f\"Total de apostas: {len(history)}\",\n        color=EMBED_COLOR\n    )\n\n    for bet in history[-10:]:\n        winner_mention = f\"<@{bet.winner_id}>\" if bet.winner_id else \"Cancelada\"\n        embed.add_field(\n            name=f\"{bet.mode.replace('-', ' ').title()}\",\n            value=(\n                f\"Jogadores: <@{bet.player1_id}> vs <@{bet.player2_id}>\\n\"\n                f\"Vencedor: {winner_mention}\\n\"\n                f\"Data: {bet.finished_at[:10] if bet.finished_at else 'N/A'}\"\n            ),\n            inline=False\n        )\n    if interaction.guild.icon:\n        embed.set_thumbnail(url=interaction.guild.icon.url)\n\n    await interaction.response.send_message(embed=embed)\n\n\n@bot.tree.command(name=\"minhas-apostas\", description=\"Ver suas apostas ativas\")\nasync def minhas_apostas(interaction: discord.Interaction):\n    user_id = interaction.user.id\n    active_bets = db.get_all_active_bets()\n\n    user_bets = [bet for bet in active_bets.values() \n                 if bet.player1_id == user_id or bet.player2_id == user_id]\n\n    if not user_bets:\n        await interaction.response.send_message(\n            \"Você não tem apostas ativas no momento.\",\n            ephemeral=True\n        )\n        return\n\n    embed = discord.Embed(\n        title=\"Suas Apostas Ativas\",\n        description=f\"Você tem {len(user_bets)} aposta(s) ativa(s)\",\n        color=EMBED_COLOR\n    )\n\n    for bet in user_bets:\n        channel = f\"<#{bet.channel_id}>\"\n        status = \"Confirmada\" if (\n            (user_id == bet.player1_id and bet.player1_confirmed) or \n            (user_id == bet.player2_id and bet.player2_confirmed)\n        ) else \"Aguardando confirmação\"\n\n        embed.add_field(\n            name=f\"{bet.mode.replace('-', ' ').title()}\",\n            value=f\"Canal: {channel}\\nStatus: {status}\",\n            inline=False\n        )\n    if interaction.guild.icon:\n        embed.set_thumbnail(url=interaction.guild.icon.url)\n\n    await interaction.response.send_message(embed=embed, ephemeral=True)\n\n\n@bot.tree.command(name=\"desbugar-filas\", description=\"[ADMIN] Cancelar todas as apostas ativas e limpar filas\")\nasync def desbugar_filas(interaction: discord.Interaction):\n    if not interaction.user.guild_permissions.administrator:\n        await interaction.response.send_message(\n            \"Apenas administradores podem usar este comando.\",\n            ephemeral=True\n        )\n        return\n\n    active_bets = db.get_all_active_bets()\n\n    if not active_bets:\n        await interaction.response.send_message(\n            \"Não há apostas ativas para cancelar.\",\n            ephemeral=True\n        )\n        return\n\n    # Defer a resposta porque pode demorar\n    await interaction.response.defer()\n\n    deleted_channels = 0\n    cancelled_bets = 0\n\n    # Cancelar todas as apostas ativas\n    for bet_id, bet in list(active_bets.items()):\n        try:\n            channel = interaction.guild.get_channel(bet.channel_id)\n            if channel:\n                await channel.delete()\n                deleted_channels += 1\n        except:\n            pass\n\n        # Mover para histórico sem vencedor (cancelada)\n        bet.finished_at = datetime.now().isoformat()\n        db.finish_bet(bet)\n        cancelled_bets += 1\n\n    # Limpar todas as filas\n    data = db._load_data()\n    data['queues'] = {}\n    db._save_data(data)\n\n    embed = discord.Embed(\n        title=\"Sistema Desbugado\",\n        description=\"Todas as apostas ativas foram canceladas e as filas limpas.\",\n        color=EMBED_COLOR\n    )\n    embed.add_field(name=\"Apostas Canceladas\", value=str(cancelled_bets), inline=True)\n    embed.add_field(name=\"Canais Deletados\", value=str(deleted_channels), inline=True)\n    embed.add_field(name=\"Filas Limpas\", value=\"Todas\", inline=True)\n    embed.set_footer(text=f\"Executado por {interaction.user.name}\")\n    if interaction.guild.icon:\n        embed.set_thumbnail(url=interaction.guild.icon.url)\n\n    await interaction.followup.send(embed=embed)\n\n\n@bot.tree.command(name=\"ajuda\", description=\"Ver todos os comandos disponíveis\")\nasync def ajuda(interaction: discord.Interaction):\n    embed = discord.Embed(\n        title=\"NZ Apostado - Comandos\",\n        description=\"Sistema de apostas profissional\",\n        color=EMBED_COLOR\n    )\n\n    embed.add_field(\n        name=\"Comandos para Jogadores\",\n        value=(\n            \"`/confirmar-pagamento` - Confirmar que enviou o pagamento\\n\"\n            \"`/minhas-apostas` - Ver suas apostas ativas\\n\"\n            \"`/historico` - Ver histórico de apostas\"\n        ),\n        inline=False\n    )\n\n    embed.add_field(\n        name=\"Comandos para Mediadores/Moderadores\",\n        value=(\n            \"`/mostrar-fila` - Criar mensagem com botão para entrar na fila\\n\"\n            \"`/finalizar-aposta` - Finalizar aposta e declarar vencedor\\n\"\n            \"`/cancelar-aposta` - Cancelar uma aposta\\n\"\n            \"`/desbugar-filas` - [ADMIN] Cancelar todas apostas e limpar filas\"\n        ),\n        inline=False\n    )\n\n    embed.add_field(\n        name=\"Como Funciona\",\n        value=(\n            \"1. Moderadores criam filas com `/mostrar-fila`\\n\"\n            \"2. Clique no botão 'Entrar na Fila' da mensagem\\n\"\n            \"3. Quando encontrar outro jogador, um canal privado será criado\\n\"\n            \"4. Envie o valor da aposta para o mediador\\n\"\n            \"5. Confirme com `/confirmar-pagamento`\\n\"\n            \"6. Jogue a partida\\n\"\n            \"7. O mediador declara o vencedor com `/finalizar-aposta`\"\n        ),\n        inline=False\n    )\n    if interaction.guild.icon:\n        embed.set_thumbnail(url=interaction.guild.icon.url)\n\n    await interaction.response.send_message(embed=embed)\n\n\ntry:\n    token = os.getenv(\"TOKEN\") or \"\"\n    if token == \"\":\n        raise Exception(\"Por favor, adicione seu token do Discord nas variáveis de ambiente (TOKEN).\")\n    \n    if IS_RAILWAY:\n        print(\"Iniciando bot no Railway...\")\n        # Railway requer que o processo não morra, então usamos configurações específicas\n        bot.run(token, log_handler=None, root_logger=True)\n    else:\n        print(\"Iniciando bot no Replit/Local...\")\n        bot.run(token)\n        \nexcept discord.HTTPException as e:\n    if e.status == 429:\n        print(\"O Discord bloqueou a conexão por excesso de requisições\")\n        print(\"Veja: https://stackoverflow.com/questions/66724687/in-discord-py-how-to-solve-the-error-for-toomanyrequests\")\n    else:\n        raise e\nexcept Exception as e:\n    print(f\"Erro ao iniciar o bot: {e}\")\n    if IS_RAILWAY:\n        # No Railway, queremos saber exatamente o que deu errado\n        import traceback\n        traceback.print_exc()\n        raise","size_bytes":42927},"nz-apostas/utils/database.py":{"content":"import json\nimport os\nfrom typing import Dict, List, Optional\nfrom models.bet import Bet\n\n\nclass Database:\n    \"\"\"Gerencia o armazenamento de dados do bot\"\"\"\n\n    def __init__(self, data_dir: str = \"data\"):\n        # Detectar ambiente Railway\n        is_railway = os.getenv(\"RAILWAY_ENVIRONMENT\") is not None or os.getenv(\"RAILWAY_STATIC_URL\") is not None\n\n        if is_railway:\n            # No Railway, usar /app/data se existir, senão criar no diretório atual\n            self.data_dir = \"/app/data\" if os.path.exists(\"/app\") else data_dir\n        else:\n            self.data_dir = data_dir\n\n        self.data_file = os.path.join(self.data_dir, \"bets.json\")\n\n        self._ensure_file_exists()\n\n    def _ensure_file_exists(self):\n        \"\"\"Garante que o arquivo de dados existe\"\"\"\n        os.makedirs(os.path.dirname(self.data_file), exist_ok=True)\n        if not os.path.exists(self.data_file):\n            self._save_data({'queues': {}, 'active_bets': {}, 'bet_history': []})\n\n    def _load_data(self) -> dict:\n        \"\"\"Carrega dados do arquivo\"\"\"\n        with open(self.data_file, 'r', encoding='utf-8') as f:\n            return json.load(f)\n\n    def _save_data(self, data: dict):\n        \"\"\"Salva dados no arquivo\"\"\"\n        with open(self.data_file, 'w', encoding='utf-8') as f:\n            json.dump(data, f, indent=2, ensure_ascii=False)\n\n    def add_to_queue(self, queue_id: str, user_id: int):\n        \"\"\"Adiciona um jogador à fila\"\"\"\n        data = self._load_data()\n        if queue_id not in data['queues']:\n            data['queues'][queue_id] = []\n        if user_id not in data['queues'][queue_id]:\n            data['queues'][queue_id].append(user_id)\n        self._save_data(data)\n\n    def remove_from_queue(self, queue_id: str, user_id: int):\n        \"\"\"Remove um jogador da fila\"\"\"\n        data = self._load_data()\n        if queue_id in data['queues'] and user_id in data['queues'][queue_id]:\n            data['queues'][queue_id].remove(user_id)\n        self._save_data(data)\n\n    def get_queue(self, queue_id: str) -> List[int]:\n        \"\"\"Retorna a fila de um painel específico\"\"\"\n        data = self._load_data()\n        return data['queues'].get(queue_id, [])\n\n    def remove_from_all_queues(self, user_id: int):\n        \"\"\"Remove um jogador de todas as filas\"\"\"\n        data = self._load_data()\n        for mode in data['queues']:\n            if user_id in data['queues'][mode]:\n                data['queues'][mode].remove(user_id)\n        self._save_data(data)\n\n    def is_user_in_active_bet(self, user_id: int) -> bool:\n        \"\"\"Verifica se um jogador está em uma aposta ativa\"\"\"\n        data = self._load_data()\n        for bet_data in data['active_bets'].values():\n            if bet_data['player1_id'] == user_id or bet_data['player2_id'] == user_id:\n                return True\n        return False\n\n    def add_active_bet(self, bet: Bet):\n        \"\"\"Adiciona uma aposta ativa\"\"\"\n        data = self._load_data()\n        data['active_bets'][bet.bet_id] = bet.to_dict()\n        self._save_data(data)\n\n    def get_active_bet(self, bet_id: str) -> Optional[Bet]:\n        \"\"\"Retorna uma aposta ativa pelo ID\"\"\"\n        data = self._load_data()\n        bet_data = data['active_bets'].get(bet_id)\n        return Bet.from_dict(bet_data) if bet_data else None\n\n    def get_bet_by_channel(self, channel_id: int) -> Optional[Bet]:\n        \"\"\"Retorna uma aposta pelo ID do canal\"\"\"\n        data = self._load_data()\n        for bet_data in data['active_bets'].values():\n            if bet_data['channel_id'] == channel_id:\n                return Bet.from_dict(bet_data)\n        return None\n\n    def update_active_bet(self, bet: Bet):\n        \"\"\"Atualiza uma aposta ativa\"\"\"\n        data = self._load_data()\n        data['active_bets'][bet.bet_id] = bet.to_dict()\n        self._save_data(data)\n\n    def finish_bet(self, bet: Bet):\n        \"\"\"Finaliza uma aposta e move para o histórico\"\"\"\n        data = self._load_data()\n        if bet.bet_id in data['active_bets']:\n            del data['active_bets'][bet.bet_id]\n            data['bet_history'].append(bet.to_dict())\n            self._save_data(data)\n\n    def get_bet_history(self) -> List[Bet]:\n        \"\"\"Retorna o histórico de apostas\"\"\"\n        data = self._load_data()\n        return [Bet.from_dict(bet_data) for bet_data in data['bet_history']]\n\n    def get_all_active_bets(self) -> Dict[str, Bet]:\n        \"\"\"Retorna todas as apostas ativas\"\"\"\n        data = self._load_data()\n        return {bet_id: Bet.from_dict(bet_data) for bet_id, bet_data in data['active_bets'].items()}","size_bytes":4570},"nz-apostas/utils/__init__.py":{"content":"","size_bytes":0},"nz-apostas/pyproject.toml":{"content":"[tool.poetry]\nname = \"python-template\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Your Name <you@example.com>\"]\n\n[tool.poetry.dependencies]\npython = \">=3.10.0,<3.11\"\ndiscord-py = \"^2.6.4\"\n\n[tool.pyright]\n# https://github.com/microsoft/pyright/blob/main/docs/configuration.md\nuseLibraryCodeForTypes = true\n\n[tool.ruff]\n# https://beta.ruff.rs/docs/configuration/\nselect = ['E', 'W', 'F', 'I', 'B', 'C4', 'ARG', 'SIM']\nignore = ['W291', 'W292', 'W293']\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"","size_bytes":545},"nz-apostas/models/bet.py":{"content":"from dataclasses import dataclass\nfrom typing import Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Bet:\n    \"\"\"Representa uma aposta ativa\"\"\"\n    bet_id: str\n    mode: str\n    player1_id: int\n    player2_id: int\n    mediator_id: int\n    channel_id: int\n    bet_value: float = 0.0\n    mediator_fee: float = 0.0\n    mediator_pix: Optional[str] = None\n    player1_confirmed: bool = False\n    player2_confirmed: bool = False\n    winner_id: Optional[int] = None\n    created_at: str = \"\"\n    finished_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def is_fully_confirmed(self) -> bool:\n        \"\"\"Verifica se ambos os jogadores confirmaram pagamento\"\"\"\n        return self.player1_confirmed and self.player2_confirmed\n    \n    def to_dict(self) -> dict:\n        \"\"\"Converte a aposta para dicionário\"\"\"\n        return {\n            'bet_id': self.bet_id,\n            'mode': self.mode,\n            'player1_id': self.player1_id,\n            'player2_id': self.player2_id,\n            'mediator_id': self.mediator_id,\n            'channel_id': self.channel_id,\n            'bet_value': self.bet_value,\n            'mediator_fee': self.mediator_fee,\n            'mediator_pix': self.mediator_pix,\n            'player1_confirmed': self.player1_confirmed,\n            'player2_confirmed': self.player2_confirmed,\n            'winner_id': self.winner_id,\n            'created_at': self.created_at,\n            'finished_at': self.finished_at\n        }\n    \n    @classmethod\n    def from_dict(cls, data: dict) -> 'Bet':\n        \"\"\"Cria uma aposta a partir de um dicionário\"\"\"\n        return cls(**data)\n","size_bytes":1714},"nz-apostas/README.md":{"content":"# NZ Apostas - Bot Discord\n\nBot profissional de apostas para Discord com sistema de filas, mediação e histórico.\n\n## Features\n\n- ✅ Sistema de filas 1v1 e 2v2\n- ✅ Mediação de apostas com confirmação de pagamento\n- ✅ Múltiplos modos de jogo (Misto, Mob)\n- ✅ Histórico de apostas\n- ✅ Canais privados automáticos\n- ✅ Sistema de PIX para mediadores\n- ✅ Comandos administrativos\n\n## Deploy\n\n### Replit (Principal)\n\nEste bot está configurado para rodar no Replit. Basta clicar no botão **Run** para iniciar.\n\n**Variáveis de Ambiente:**\n- `TOKEN`: Token do bot Discord\n\n### Railway (Backup)\n\nPara deploy no Railway, consulte o guia completo: [DEPLOY_RAILWAY.md](DEPLOY_RAILWAY.md)\n\n## Comandos\n\n### Jogadores\n- `/confirmar-pagamento` - Confirmar envio do pagamento\n- `/minhas-apostas` - Ver apostas ativas\n- `/historico` - Ver histórico de apostas\n\n### Moderadores\n- `/mostrar-fila` - Criar fila com botões\n- `/finalizar-aposta` - Declarar vencedor\n- `/cancelar-aposta` - Cancelar aposta\n\n### Administradores\n- `/desbugar-filas` - Limpar sistema (emergência)\n\n## Como Usar\n\n1. Moderador cria fila com `/mostrar-fila`\n2. Jogadores clicam em \"Entrar na Fila\" (1v1) ou escolhem time (2v2)\n3. Sistema cria canal privado automaticamente\n4. Mediador aceita e fornece PIX\n5. Jogadores enviam pagamento e confirmam\n6. Partida é liberada\n7. Mediador declara vencedor com `/finalizar-aposta`\n\n## Estrutura\n\n```\nnz-apostas/\n├── main.py              # Bot principal\n├── models/\n│   └── bet.py          # Modelo de aposta\n├── utils/\n│   └── database.py     # Sistema de dados\n├── data/\n│   └── bets.json       # Dados persistentes\n└── DEPLOY_RAILWAY.md   # Guia Railway\n```\n\n## Desenvolvimento\n\n**Dependências:**\n- Python 3.10\n- discord.py 2.6.4\n\n**Instalação Local:**\n```bash\npip install discord.py\npython main.py\n```\n\n## Troubleshooting\n\n### 429 Too Many Requests\nSe você receber este erro, veja: https://stackoverflow.com/questions/66724687/in-discord-py-how-to-solve-the-error-for-toomanyrequests\n\n### Bot não conecta\n- Verifique se o TOKEN está configurado\n- Confirme que o bot tem as permissões necessárias no servidor\n\n### Comandos não aparecem\n- Aguarde até 1 hora para sincronização global\n- Ou remova/readicione o bot ao servidor\n\n## Suporte\n\nPara dúvidas sobre configuração do bot Discord, consulte:\n- [Documentação discord.py](https://discordpy.readthedocs.io/)\n- [Discord Developer Portal](https://discord.com/developers/applications)\n\n---\n\n**Deploy Principal**: Replit  \n**Deploy Backup**: Railway ([Ver guia](DEPLOY_RAILWAY.md))","size_bytes":2624}},"version":2}