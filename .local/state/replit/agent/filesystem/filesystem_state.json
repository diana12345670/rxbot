{"file_contents":{"nz-apostas/DEPLOY_RAILWAY.md":{"content":"\n# Deploy do Bot NZ Apostas no Railway\n\nEste guia explica como fazer o deploy do bot Discord no Railway.\n\n## ‚ú® Detec√ß√£o Autom√°tica de Ambiente\n\nO bot **detecta automaticamente** quando est√° rodando no Railway atrav√©s das vari√°veis de ambiente `RAILWAY_ENVIRONMENT` ou `RAILWAY_STATIC_URL`. Voc√™ n√£o precisa fazer nenhuma configura√ß√£o adicional!\n\nQuando detectado no Railway, o bot:\n- üöÇ Exibe mensagem \"Detectado ambiente Railway\"\n- üìÅ Usa o diret√≥rio `/app/data` para dados persistentes\n- üîç Mostra traceback completo de erros\n- ‚öôÔ∏è Usa configura√ß√µes de logging otimizadas\n\n## Pr√©-requisitos\n\n1. Conta no [Railway](https://railway.app/)\n2. Token do bot Discord configurado\n3. C√≥digo do bot no GitHub (ou upload direto)\n\n## Passo a Passo\n\n### 1. Preparar o Reposit√≥rio\n\nSe voc√™ ainda n√£o tem o c√≥digo no GitHub:\n\n1. Crie um novo reposit√≥rio no GitHub\n2. Fa√ßa upload de todos os arquivos da pasta `nz-apostas`\n3. Certifique-se de que os arquivos `railway.json`, `Procfile`, `runtime.txt` e `requirements.txt` est√£o inclu√≠dos\n\n### 2. Criar Projeto no Railway\n\n1. Acesse [railway.app](https://railway.app/)\n2. Fa√ßa login com sua conta GitHub\n3. Clique em **\"New Project\"**\n4. Selecione **\"Deploy from GitHub repo\"**\n5. Escolha o reposit√≥rio com o c√≥digo do bot\n6. Railway detectar√° automaticamente que √© um projeto Python\n\n### 3. Configurar Vari√°veis de Ambiente\n\n1. No dashboard do projeto, v√° em **\"Variables\"**\n2. Adicione a seguinte vari√°vel:\n   - `TOKEN`: Cole o token do seu bot Discord\n\n**IMPORTANTE:** \n- Nunca compartilhe ou commite o token do bot no GitHub!\n- O Railway define automaticamente `RAILWAY_ENVIRONMENT` e `RAILWAY_STATIC_URL`\n\n### 4. Configurar Deploy\n\nRailway detectar√° automaticamente o `railway.json` e `Procfile`. Se necess√°rio:\n\n1. V√° em **\"Settings\"**\n2. Em **\"Deploy\"**, confirme que:\n   - **Start Command**: `python main.py`\n   - **Build Command**: (deixe em branco, Railway instalar√° depend√™ncias automaticamente)\n\n### 5. Deploy\n\n1. Railway iniciar√° o deploy automaticamente\n2. Aguarde a instala√ß√£o das depend√™ncias\n3. O bot iniciar√° quando o deploy estiver completo\n4. Verifique os logs em **\"Deployments\"** ‚Üí **\"View Logs\"**\n\n### 6. Verificar Status\n\nPara confirmar que o bot est√° online:\n\n1. Verifique os logs do Railway\n2. Procure por mensagens como:\n   ```\n   üöÇ Detectado ambiente Railway\n   Iniciando bot no Railway...\n   Bot conectado como NZ apostas#1303\n   Nome: NZ apostas\n   ID: 1431031103401103474\n   8 comandos sincronizados\n   ```\n3. Teste um comando no Discord\n\n## Troubleshooting\n\n### Bot n√£o conecta\n\n- Verifique se o `TOKEN` est√° configurado corretamente nas vari√°veis de ambiente\n- Confirme que o token √© v√°lido no [Discord Developer Portal](https://discord.com/developers/applications)\n- Verifique os logs completos no Railway (o bot mostra traceback detalhado)\n\n### Erros de depend√™ncias\n\n- Verifique se o arquivo `requirements.txt` est√° presente\n- Confirme que `discord.py==2.6.4` est√° listado\n\n### Bot desconecta frequentemente\n\n- Railway oferece planos gratuitos com limita√ß√µes\n- Considere fazer upgrade para um plano pago para melhor estabilidade\n\n### Logs n√£o aparecem\n\n- V√° em **\"Deployments\"** ‚Üí clique no deploy ativo ‚Üí **\"View Logs\"**\n- Os logs podem levar alguns segundos para aparecer\n- Procure pela mensagem \"üöÇ Detectado ambiente Railway\"\n\n### Banco de dados n√£o persiste\n\n- Configure um Volume no Railway (veja se√ß√£o abaixo)\n- Monte o volume em `/app/data`\n\n## Estrutura de Arquivos Necess√°ria\n\n```\nnz-apostas/\n‚îú‚îÄ‚îÄ main.py                 # C√≥digo principal do bot (com detec√ß√£o Railway)\n‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ bet.py\n‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ database.py        # Sistema de dados (com suporte Railway)\n‚îú‚îÄ‚îÄ data/\n‚îÇ   ‚îî‚îÄ‚îÄ bets.json          # Ser√° criado automaticamente\n‚îú‚îÄ‚îÄ requirements.txt       # Depend√™ncias Python\n‚îú‚îÄ‚îÄ runtime.txt            # Vers√£o do Python\n‚îú‚îÄ‚îÄ Procfile              # Comando de start\n‚îú‚îÄ‚îÄ railway.json          # Configura√ß√£o Railway\n‚îî‚îÄ‚îÄ README.md\n```\n\n## Persist√™ncia de Dados\n\n**ATEN√á√ÉO:** O Railway n√£o mant√©m arquivos entre deploys por padr√£o. O arquivo `data/bets.json` ser√° perdido em cada redeploy.\n\n### Solu√ß√µes:\n\n1. **Railway Volumes** (Recomendado):\n   ```bash\n   # O bot detectar√° automaticamente o volume se montado em /app/data\n   ```\n   - No Railway, v√° em **\"Settings\"** ‚Üí **\"Volumes\"**\n   - Crie um novo volume\n   - Monte-o em `/app/data`\n   - O bot usar√° automaticamente este diret√≥rio\n\n2. **Banco de Dados Externo**:\n   - Use PostgreSQL, MongoDB ou outro banco\n   - Railway oferece add-ons de banco de dados\n\n3. **Armazenamento em Nuvem**:\n   - Use S3, Google Cloud Storage, etc.\n   - Sincronize o `bets.json` periodicamente\n\n## Monitoramento\n\n- **Logs**: Railway ‚Üí Deployments ‚Üí View Logs\n  - Procure por \"üöÇ Detectado ambiente Railway\"\n  - Erros mostram traceback completo\n- **M√©tricas**: Railway ‚Üí Observability\n- **Alertas**: Configure notifica√ß√µes no Discord para erros\n\n## Redeploy Autom√°tico\n\nRailway faz redeploy autom√°tico quando voc√™:\n- Faz push para o branch principal do GitHub\n- Modifica vari√°veis de ambiente\n- Clica em \"Redeploy\" manualmente\n\n## Custos\n\n- **Plano Gratuito**: \n  - $5 em cr√©ditos por m√™s\n  - 500 horas de execu√ß√£o\n  - Ideal para testes\n\n- **Plano Hobby**: \n  - $5/m√™s + uso\n  - Sem limite de horas\n  - Recomendado para produ√ß√£o\n\n## Suporte\n\n- [Documenta√ß√£o Railway](https://docs.railway.app/)\n- [Discord da Railway](https://discord.gg/railway)\n- [Status do Railway](https://status.railway.app/)\n\n## Diferen√ßas vs Replit\n\n| Recurso | Replit | Railway |\n|---------|--------|---------|\n| Deploy Autom√°tico | ‚úÖ | ‚úÖ |\n| Detec√ß√£o de Ambiente | ‚úÖ | ‚úÖ Autom√°tica |\n| Persist√™ncia | ‚úÖ Built-in | ‚ö†Ô∏è Requer Volume |\n| Logs | ‚úÖ | ‚úÖ Mais detalhados |\n| Custo Gratuito | Limitado | $5 cr√©ditos/m√™s |\n| Uptime | Bom | Excelente |\n| Facilidade | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |\n\n## Pr√≥ximos Passos\n\n1. ‚úÖ Deploy inicial (detec√ß√£o autom√°tica funciona!)\n2. Configure um volume persistente para `/app/data`\n3. Adicione monitoramento de erros\n4. Configure backup autom√°tico dos dados\n5. Implemente health checks\n\n---\n\n**Nota**: Este bot est√° atualmente deployado no Replit. Esta √© apenas uma c√≥pia de backup para Railway que detecta automaticamente o ambiente.\n","size_bytes":6467},"nz-apostas/INSTRUCOES.md":{"content":"# üéÆ NZ Apostado - Bot de Apostas Discord\n\nSistema completo de apostas para Discord com filas, mediadores e gerenciamento autom√°tico de canais.\n\n## üìã Funcionalidades Implementadas\n\n‚úÖ **Sistema de Filas por Modo**\n- 1v1 Misto\n- 1v1 Mob\n- 2v2 Misto\n\n‚úÖ **Cria√ß√£o Autom√°tica de Canais Privados**\n- Quando 2 jogadores entram na mesma fila, um canal privado √© criado automaticamente\n- Sistema de bot√£o para ADMs aceitarem media√ß√£o\n- Cada mediador insere sua pr√≥pria chave PIX\n\n‚úÖ **Sistema de Confirma√ß√£o de Pagamento**\n- Cada jogador confirma que enviou o pagamento\n- Mediador recebe notifica√ß√µes das confirma√ß√µes\n\n‚úÖ **Finaliza√ß√£o de Apostas**\n- Mediador declara o vencedor\n- Canal √© automaticamente deletado ap√≥s 30 segundos\n\n‚úÖ **Sistema Anti-Duplica√ß√£o**\n- Jogadores s√≥ podem estar em uma aposta ativa por vez\n\n‚úÖ **Logs e Hist√≥rico**\n- Todas as apostas s√£o registradas\n- Hist√≥rico acess√≠vel por comando\n\n## üöÄ Como Configurar\n\n### 1. Habilitar Intents no Portal do Discord\n\n**IMPORTANTE:** O bot precisa de intents privilegiados habilitados. Siga estes passos:\n\n1. Acesse [Discord Developer Portal](https://discord.com/developers/applications/)\n2. Selecione sua aplica√ß√£o (bot)\n3. V√° em **Bot** no menu lateral\n4. Role at√© **Privileged Gateway Intents**\n5. Habilite as seguintes op√ß√µes:\n   - ‚úÖ **Presence Intent**\n   - ‚úÖ **Server Members Intent**\n   - ‚úÖ **Message Content Intent**\n6. Clique em **Save Changes**\n\n### 2. Convidar o Bot\n\nUse este link para convidar o bot (substitua `YOUR_CLIENT_ID` pelo ID da sua aplica√ß√£o):\n\n```\nhttps://discord.com/api/oauth2/authorize?client_id=YOUR_CLIENT_ID&permissions=8&scope=bot%20applications.commands\n```\n\n### 3. Garantir Permiss√µes de Administrador\n\nO sistema identifica mediadores atrav√©s de permiss√µes de **Administrador** no Discord. Certifique-se de que os membros que devem mediar apostas tenham esse cargo.\n\n## üìñ Comandos Dispon√≠veis\n\n### üë• Comandos para Jogadores\n\n- `/entrar-fila` - Entrar na fila de apostas\n- `/sair-fila` - Sair da fila de apostas\n- `/ver-filas` - Ver status das filas\n- `/confirmar-pagamento` - Confirmar que enviou o pagamento\n- `/minhas-apostas` - Ver suas apostas ativas\n- `/historico` - Ver hist√≥rico de apostas\n- `/ajuda` - Ver todos os comandos\n\n### üë®‚Äç‚öñÔ∏è Comandos para Mediadores\n\n- `/finalizar-aposta` - Finalizar aposta e declarar vencedor\n- `/cancelar-aposta` - Cancelar uma aposta\n\n## üéØ Como Funciona\n\n1. **Jogador entra na fila:**\n   - Use `/entrar-fila` e escolha o modo\n   - Aguarde outro jogador\n\n2. **Canal privado √© criado:**\n   - Quando 2 jogadores est√£o na fila, um canal privado √© criado\n   - Mensagem √© enviada marcando os Administradores\n   - Aparece um bot√£o verde \"üë®‚Äç‚öñÔ∏è Aceitar Media√ß√£o\"\n\n3. **ADM aceita mediar:**\n   - Primeiro ADM que clicar no bot√£o vira o mediador\n   - Abre um formul√°rio para ele inserir a chave PIX dele\n   - Sistema automaticamente bloqueia outros ADMs de aceitar\n   - Jogadores s√£o notificados que um mediador aceitou\n\n4. **Confirma√ß√£o de pagamento:**\n   - Ambos jogadores enviam o valor da aposta para o PIX do mediador\n   - Cada um usa `/confirmar-pagamento` no canal privado\n   - Mediador recebe notifica√ß√£o a cada confirma√ß√£o\n\n5. **Partida:**\n   - Quando ambos confirmarem, a partida pode come√ßar\n   - Jogadores jogam a partida\n\n6. **Finaliza√ß√£o:**\n   - Mediador usa `/finalizar-aposta @vencedor` para declarar o vencedor\n   - Canal √© automaticamente deletado ap√≥s 30 segundos\n\n## üìÅ Estrutura do Projeto\n\n```\n.\n‚îú‚îÄ‚îÄ main.py                 # Arquivo principal do bot\n‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ bet.py             # Modelo de dados das apostas\n‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ database.py        # Gerenciamento de dados (JSON)\n‚îî‚îÄ‚îÄ data/\n    ‚îî‚îÄ‚îÄ bets.json          # Armazenamento de apostas (criado automaticamente)\n```\n\n## üíæ Armazenamento de Dados\n\nOs dados s√£o armazenados em `data/bets.json` e incluem:\n\n- **Filas ativas:** Jogadores aguardando em cada modo\n- **Apostas ativas:** Apostas em andamento\n- **Hist√≥rico:** Todas as apostas finalizadas\n\n## ‚ö†Ô∏è Problemas Comuns\n\n### Bot n√£o responde aos comandos\n\n1. Verifique se habilitou os intents privilegiados\n2. Certifique-se de que o bot tem permiss√µes de administrador no servidor\n3. Aguarde alguns minutos ap√≥s habilitar os intents\n\n### Comandos n√£o aparecem\n\n1. Aguarde alguns minutos ap√≥s adicionar o bot\n2. Reinicie o Discord\n3. Verifique se o bot est√° online\n\n### Erro de permiss√µes ao criar canais\n\nO bot precisa de permiss√£o de administrador ou pelo menos:\n- Gerenciar Canais\n- Criar Convites\n- Enviar Mensagens\n- Mencionar Todos\n\n## üîß Personaliza√ß√£o\n\nVoc√™ pode personalizar:\n\n1. **Modos de jogo:** Edite a lista `MODES` em `main.py`\n2. **PIX do mediador:** Altere `MEDIATOR_PIX` em `main.py`\n3. **Nome da categoria:** Altere `ACTIVE_BETS_CATEGORY` em `main.py`\n4. **Tempo de dele√ß√£o:** Altere o valor em `await asyncio.sleep(30)`\n\n## üìù Logs\n\nO bot registra todas as atividades:\n- Jogadores que entraram/sa√≠ram de filas\n- Apostas criadas\n- Confirma√ß√µes de pagamento\n- Apostas finalizadas\n- Vencedores\n\n## üÜò Suporte\n\nSe tiver problemas:\n\n1. Verifique os logs do bot no console\n2. Confirme que o TOKEN est√° configurado corretamente\n3. Certifique-se de que os intents est√£o habilitados\n4. Verifique as permiss√µes do bot no servidor\n\n## üìÑ Licen√ßa\n\nEste bot foi criado para uso pessoal/privado.\n","size_bytes":5506},"nz-apostas/models/__init__.py":{"content":"","size_bytes":0},"nz-apostas/replit.md":{"content":"# NZ Apostado - Discord Betting Bot\n\n## Overview\n\nNZ Apostado is a Discord bot that manages a betting system with queue management, automated private channel creation, and bet mediation. The bot allows users to join betting queues for different game modes (1v1 Mixed, 1v1 Mob, 2v2 Mixed), automatically matches players, creates private channels for matched bets, handles payment confirmations, and manages bet finalization through mediators.\n\nThe system is built using Python with the discord.py library and implements a file-based JSON storage solution for managing queues, active bets, and bet history.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Application Structure\n\n**Problem:** Need to organize a Discord bot with betting logic, data persistence, and command handling.\n\n**Solution:** Modular architecture separating concerns:\n- `main.py` - Bot initialization, Discord event handlers, and slash commands\n- `models/bet.py` - Data model for bet representation\n- `utils/database.py` - Data persistence layer with JSON file storage\n- `data/bets.json` - Persistent storage for queues, active bets, and history\n\n**Rationale:** This separation allows independent development and testing of business logic, data models, and Discord integration. The dataclass-based Bet model provides type safety and clear data structure.\n\n### Bot Framework\n\n**Problem:** Need to interact with Discord API and handle user commands.\n\n**Solution:** Discord.py library with slash commands (app_commands) for modern Discord UX.\n\n**Key decisions:**\n- Uses `discord.ext.commands.Bot` as the base bot class\n- Implements Discord Intents for message content, member data, and guild access\n- Uses slash commands (`@bot.tree.command`) instead of traditional prefix commands for better discoverability\n\n**Alternatives considered:** Traditional prefix commands (e.g., `!command`) were available but slash commands provide better user experience and autocomplete functionality.\n\n### Data Persistence\n\n**Problem:** Need to persist betting queues, active bets, and historical data across bot restarts.\n\n**Solution:** JSON file-based storage with a database abstraction layer (`Database` class).\n\n**Structure:**\n```json\n{\n  \"queues\": {},           // Mode-specific player queues\n  \"active_bets\": {},      // Currently ongoing bets\n  \"bet_history\": []       // Completed bet records\n}\n```\n\n**Pros:**\n- Simple setup with no external database dependencies\n- Human-readable format for debugging\n- Easy to version control and backup\n\n**Cons:**\n- Not suitable for high-concurrency scenarios\n- Limited query capabilities\n- Potential data loss if file corruption occurs\n\n**Alternatives considered:** SQL databases (SQLite, PostgreSQL) would provide better concurrency and query capabilities but add complexity for this use case.\n\n### Bet Lifecycle Management\n\n**Problem:** Manage complex state transitions for bets from queue ‚Üí matching ‚Üí confirmation ‚Üí completion.\n\n**Solution:** State machine pattern using the `Bet` dataclass with boolean flags for confirmation states.\n\n**States tracked:**\n- Queue membership (managed by Database)\n- Active bet creation (player pairing)\n- Payment confirmations (`player1_confirmed`, `player2_confirmed`)\n- Winner declaration (`winner_id`)\n- Timestamps (`created_at`, `finished_at`)\n\n**Anti-duplication mechanism:** `is_user_in_active_bet()` method prevents users from joining multiple bets simultaneously.\n\n### Channel Management\n\n**Problem:** Create private, temporary channels for matched betting pairs.\n\n**Solution:** Automatic channel creation under \"üí∞„ÉªApostas Ativas\" category with permission-based access control.\n\n**Access control:**\n- Only matched players can view/interact\n- Mediator has full access\n- Bot has management permissions\n- Channel auto-deletion after bet completion (30-second delay)\n\n### Command Interface\n\n**Problem:** Provide user-friendly betting commands.\n\n**Solution:** Discord slash commands with choices for game modes.\n\n**Implemented commands:**\n- `/entrar-fila` - Join betting queue with mode selection\n- `/sair-fila` - Leave betting queue\n- `/ver-filas` - View queue status\n- `/confirmar-pagamento` - Confirm payment sent to mediator\n- `/finalizar-aposta` - [Mediator only] Finalize bet and declare winner\n- `/cancelar-aposta` - [Mediator only] Cancel ongoing bet\n- `/historico` - View bet history\n- `/minhas-apostas` - View your active bets\n- `/ajuda` - View all available commands\n\n**Choice pattern:** Uses `app_commands.Choice` to provide predefined options, preventing invalid mode inputs.\n\n### Race Condition Prevention\n\n**Problem:** Concurrent queue matches could create duplicate active bets for the same player.\n\n**Solution:** Provisional bet reservation system.\n\n**Implementation:**\n1. Before any async Discord API calls, create a provisional active bet (blocks concurrent matches)\n2. Remove players from ALL queues (not just current mode)\n3. On success: replace provisional bet with real bet\n4. On failure: remove provisional bet and re-queue players\n\nThis ensures atomic player reservation and prevents race conditions in high-traffic scenarios.\n\n### Mediator Selection\n\n**Problem:** Ensure mediator is always independent from matched players.\n\n**Solution:** Strict filtering and validation.\n\n**Implementation:**\n- Filter guild members to exclude bots AND both players\n- If no valid mediators available: abort creation and re-queue players\n- Never allows a player to be their own mediator, even in small guilds\n\n## Recent Changes (October 23, 2025)\n\n### Complete Bot Implementation\n- Implemented full betting system with queue management\n- Added private channel creation with access control\n- Payment confirmation system with mediator notifications\n- Bet finalization with automatic channel cleanup\n- Comprehensive logging and history tracking\n\n### Critical Bug Fixes\n- Fixed race condition allowing duplicate active bets\n- Fixed mediator selection to prevent players being their own mediator\n- Added provisional bet system for atomic player reservation\n- Added queue restoration on failed bet creation\n\n### Configuration Management\n\n**Problem:** Store sensitive data like bot tokens and PIX keys.\n\n**Solution:** Environment variables for secrets, constants for static configuration.\n\n- Bot token: Environment variable `TOKEN` (referenced in README)\n- PIX key: Hardcoded constant `MEDIATOR_PIX` (should be environment variable)\n- Game modes: Python list constant `MODES`\n\n## External Dependencies\n\n### Discord.py Library\n\n**Purpose:** Primary framework for Discord bot functionality.\n\n**Features used:**\n- `discord.ext.commands` - Bot command framework\n- `discord.app_commands` - Slash command implementation\n- `discord.Intents` - Gateway intents for accessing Discord events\n- Discord object models (User, Channel, Guild, etc.)\n\n**Required intents:**\n- Message Content Intent (privileged)\n- Server Members Intent (privileged)\n- Presence Intent (privileged)\n\n### Python Standard Library\n\n**Dependencies:**\n- `json` - Data serialization/deserialization\n- `os` - File system operations and environment variables\n- `datetime` - Timestamp generation\n- `random` - Likely used for mediator selection or bet ID generation\n- `dataclasses` - Type-safe data models\n- `typing` - Type hints for better code documentation\n\n### Discord Developer Portal\n\n**Purpose:** Bot registration and permission management.\n\n**Configuration required:**\n- Application/bot creation\n- Privileged gateway intents enablement\n- OAuth2 URL generation for bot invitation\n- Bot token generation\n\n### File System\n\n**Purpose:** Persistent storage backend.\n\n**Requirements:**\n- Read/write access to `data/` directory\n- JSON file persistence (`data/bets.json`)\n\n**Note:** The current implementation uses JSON file storage, but the architecture would support migration to a relational database (e.g., PostgreSQL) if needed for scalability.","size_bytes":7910},"nz-apostas/main.py":{"content":"import os\nimport discord\nfrom discord import app_commands\nfrom discord.ext import commands\nimport random\nfrom datetime import datetime\nfrom models.bet import Bet\nfrom utils.database import Database\n\n# Detectar se est√° rodando no Railway\nIS_RAILWAY = os.getenv(\"RAILWAY_ENVIRONMENT\") is not None or os.getenv(\"RAILWAY_STATIC_URL\") is not None\n\nif IS_RAILWAY:\n    print(\"üöÇ Detectado ambiente Railway\")\nelse:\n    print(\"üíª Detectado ambiente Replit/Local\")\n\nintents = discord.Intents.default()\nintents.message_content = True\nintents.members = True\nintents.guilds = True\n\nbot = commands.Bot(command_prefix=\"!\", intents=intents)\ndb = Database()\n\nMODES = [\"1v1-misto\", \"1v1-mob\", \"2v2-misto\"]\nACTIVE_BETS_CATEGORY = \"üí∞ Apostas Ativas\"\nEMBED_COLOR = 0x5865F2\n\n\nclass QueueButton(discord.ui.View):\n    def __init__(self, mode: str, bet_value: float, mediator_fee: float, message_id: int = None):\n        super().__init__(timeout=None)\n        self.mode = mode\n        self.bet_value = bet_value\n        self.mediator_fee = mediator_fee\n        self.message_id = message_id\n        self.queue_id = f\"{mode}_{message_id}\" if message_id else \"\"\n        self.is_2v2 = \"2v2\" in mode\n\n        # Remove o bot√£o \"Entrar na Fila\" se for 2v2\n        if self.is_2v2:\n            self.remove_item(self.join_queue_button)\n        else:\n            # Remove os bot√µes de time se for 1v1\n            self.remove_item(self.join_team1_button)\n            self.remove_item(self.join_team2_button)\n\n    async def update_queue_message(self, interaction: discord.Interaction):\n        \"\"\"Atualiza a mensagem da fila com os jogadores atuais\"\"\"\n        if not self.message_id:\n            return\n\n        try:\n            message = await interaction.channel.fetch_message(self.message_id)\n\n            if self.is_2v2:\n                team1_queue = db.get_queue(f\"{self.queue_id}_team1\")\n                team2_queue = db.get_queue(f\"{self.queue_id}_team2\")\n\n                # Time 1\n                team1_names = []\n                for user_id in team1_queue:\n                    try:\n                        member = await interaction.guild.fetch_member(user_id)\n                        team1_names.append(member.mention)\n                    except:\n                        team1_names.append(f\"<@{user_id}>\")\n\n                # Time 2\n                team2_names = []\n                for user_id in team2_queue:\n                    try:\n                        member = await interaction.guild.fetch_member(user_id)\n                        team2_names.append(member.mention)\n                    except:\n                        team2_names.append(f\"<@{user_id}>\")\n\n                team1_text = \"\\n\".join(team1_names) if team1_names else \"Nenhum jogador\"\n                team2_text = \"\\n\".join(team2_names) if team2_names else \"Nenhum jogador\"\n\n                embed = discord.Embed(\n                    title=self.mode.replace('-', ' ').title(),\n                    color=EMBED_COLOR\n                )\n\n                embed.add_field(name=\"Valor\", value=f\"R$ {self.bet_value:.2f}\".replace('.', ','), inline=True)\n                embed.add_field(name=\"Time 1\", value=team1_text, inline=True)\n                embed.add_field(name=\"Time 2\", value=team2_text, inline=True)\n                if interaction.guild.icon:\n                    embed.set_thumbnail(url=interaction.guild.icon.url)\n            else:\n                queue = db.get_queue(self.queue_id)\n\n                # Busca os nomes dos jogadores na fila\n                player_names = []\n                for user_id in queue:\n                    try:\n                        member = await interaction.guild.fetch_member(user_id)\n                        player_names.append(member.mention)\n                    except:\n                        player_names.append(f\"<@{user_id}>\")\n\n                players_text = \"\\n\".join(player_names) if player_names else \"Nenhum jogador na fila\"\n\n                embed = discord.Embed(\n                    title=self.mode.replace('-', ' ').title(),\n                    color=EMBED_COLOR\n                )\n\n                embed.add_field(name=\"Valor\", value=f\"R$ {self.bet_value:.2f}\".replace('.', ','), inline=True)\n                embed.add_field(name=\"Fila\", value=players_text if players_text != \"Nenhum jogador na fila\" else \"Vazio\", inline=True)\n                if interaction.guild.icon:\n                    embed.set_thumbnail(url=interaction.guild.icon.url)\n\n            await message.edit(embed=embed)\n        except:\n            pass\n\n    @discord.ui.button(label='Entrar na Fila', style=discord.ButtonStyle.blurple, row=0)\n    async def join_queue_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        # Este bot√£o n√£o aparece no modo 2v2\n        if self.is_2v2:\n            return\n\n        user_id = interaction.user.id\n\n        if db.is_user_in_active_bet(user_id):\n            await interaction.response.send_message(\n                \"Voc√™ j√° est√° em uma aposta ativa. Finalize ela antes de entrar em outra fila.\",\n                ephemeral=True\n            )\n            return\n\n        queue = db.get_queue(self.queue_id)\n\n        if user_id in queue:\n            await interaction.response.send_message(\n                \"Voc√™ j√° est√° nesta fila.\",\n                ephemeral=True\n            )\n            return\n\n        db.add_to_queue(self.queue_id, user_id)\n        queue = db.get_queue(self.queue_id)\n\n        embed = discord.Embed(\n            title=\"‚úÖ Entrou na fila\",\n            description=f\"{self.mode.replace('-', ' ').title()} - {len(queue)}/2\",\n            color=EMBED_COLOR\n        )\n        if interaction.guild.icon:\n            embed.set_thumbnail(url=interaction.guild.icon.url)\n\n        await interaction.response.send_message(embed=embed, ephemeral=True)\n\n        # Atualiza a mensagem principal\n        await self.update_queue_message(interaction)\n\n        if len(queue) >= 2:\n            player1_id = queue[0]\n            player2_id = queue[1]\n\n            db.remove_from_queue(self.queue_id, player1_id)\n            db.remove_from_queue(self.queue_id, player2_id)\n\n            # Atualiza a mensagem ap√≥s remover os jogadores\n            await self.update_queue_message(interaction)\n\n            await create_bet_channel(interaction.guild, self.mode, player1_id, player2_id, self.bet_value, self.mediator_fee)\n\n    @discord.ui.button(label='Sair da Fila', style=discord.ButtonStyle.gray, row=0)\n    async def leave_queue_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        user_id = interaction.user.id\n\n        if self.is_2v2:\n            team1_queue_id = f\"{self.queue_id}_team1\"\n            team2_queue_id = f\"{self.queue_id}_team2\"\n\n            team1_queue = db.get_queue(team1_queue_id)\n            team2_queue = db.get_queue(team2_queue_id)\n\n            if user_id in team1_queue:\n                db.remove_from_queue(team1_queue_id, user_id)\n                embed = discord.Embed(\n                    title=\"‚ùå Saiu - Time 1\",\n                    color=EMBED_COLOR\n                )\n                if interaction.guild.icon:\n                    embed.set_thumbnail(url=interaction.guild.icon.url)\n                await interaction.response.send_message(embed=embed, ephemeral=True)\n                await self.update_queue_message(interaction)\n                return\n            elif user_id in team2_queue:\n                db.remove_from_queue(team2_queue_id, user_id)\n                embed = discord.Embed(\n                    title=\"‚ùå Saiu - Time 2\",\n                    color=EMBED_COLOR\n                )\n                if interaction.guild.icon:\n                    embed.set_thumbnail(url=interaction.guild.icon.url)\n                await interaction.response.send_message(embed=embed, ephemeral=True)\n                await self.update_queue_message(interaction)\n                return\n            else:\n                await interaction.response.send_message(\n                    \"Voc√™ n√£o est√° em nenhum time.\",\n                    ephemeral=True\n                )\n                return\n        else:\n            queue = db.get_queue(self.queue_id)\n\n            if user_id not in queue:\n                await interaction.response.send_message(\n                    \"Voc√™ n√£o est√° nesta fila.\",\n                    ephemeral=True\n                )\n                return\n\n            db.remove_from_queue(self.queue_id, user_id)\n\n            embed = discord.Embed(\n                title=\"‚ùå Saiu da fila\",\n                color=EMBED_COLOR\n            )\n            if interaction.guild.icon:\n                embed.set_thumbnail(url=interaction.guild.icon.url)\n\n            await interaction.response.send_message(embed=embed, ephemeral=True)\n\n            # Atualiza a mensagem principal\n            await self.update_queue_message(interaction)\n\n    @discord.ui.button(label='Entrar no Time 1', style=discord.ButtonStyle.blurple, row=0)\n    async def join_team1_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not self.is_2v2:\n            await interaction.response.send_message(\n                \"Este bot√£o √© exclusivo do modo 2v2.\",\n                ephemeral=True\n            )\n            return\n\n        user_id = interaction.user.id\n\n        if db.is_user_in_active_bet(user_id):\n            await interaction.response.send_message(\n                \"Voc√™ j√° est√° em uma aposta ativa. Finalize ela antes de entrar em outra fila.\",\n                ephemeral=True\n            )\n            return\n\n        team1_queue_id = f\"{self.queue_id}_team1\"\n        team2_queue_id = f\"{self.queue_id}_team2\"\n\n        team1_queue = db.get_queue(team1_queue_id)\n        team2_queue = db.get_queue(team2_queue_id)\n\n        if user_id in team1_queue:\n            await interaction.response.send_message(\n                \"Voc√™ j√° est√° no Time 1.\",\n                ephemeral=True\n            )\n            return\n\n        if user_id in team2_queue:\n            await interaction.response.send_message(\n                \"Voc√™ j√° est√° no Time 2. Saia primeiro para entrar no Time 1.\",\n                ephemeral=True\n            )\n            return\n\n        if len(team1_queue) >= 2:\n            await interaction.response.send_message(\n                \"O Time 1 j√° est√° completo.\",\n                ephemeral=True\n            )\n            return\n\n        db.add_to_queue(team1_queue_id, user_id)\n        team1_queue = db.get_queue(team1_queue_id)\n\n        embed = discord.Embed(\n            title=\"‚úÖ Time 1\",\n            description=f\"{self.mode.replace('-', ' ').title()} - {len(team1_queue)}/2\",\n            color=EMBED_COLOR\n        )\n        if interaction.guild.icon:\n            embed.set_thumbnail(url=interaction.guild.icon.url)\n\n        await interaction.response.send_message(embed=embed, ephemeral=True)\n        await self.update_queue_message(interaction)\n\n        # Verifica se ambos os times est√£o completos\n        team2_queue = db.get_queue(team2_queue_id)\n        if len(team1_queue) == 2 and len(team2_queue) == 2:\n            await self.create_2v2_match(interaction.guild, team1_queue, team2_queue)\n\n    @discord.ui.button(label='Entrar no Time 2', style=discord.ButtonStyle.blurple, row=0)\n    async def join_team2_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not self.is_2v2:\n            await interaction.response.send_message(\n                \"Este bot√£o √© exclusivo do modo 2v2.\",\n                ephemeral=True\n            )\n            return\n\n        user_id = interaction.user.id\n\n        if db.is_user_in_active_bet(user_id):\n            await interaction.response.send_message(\n                \"Voc√™ j√° est√° em uma aposta ativa. Finalize ela antes de entrar em outra fila.\",\n                ephemeral=True\n            )\n            return\n\n        team1_queue_id = f\"{self.queue_id}_team1\"\n        team2_queue_id = f\"{self.queue_id}_team2\"\n\n        team1_queue = db.get_queue(team1_queue_id)\n        team2_queue = db.get_queue(team2_queue_id)\n\n        if user_id in team2_queue:\n            await interaction.response.send_message(\n                \"Voc√™ j√° est√° no Time 2.\",\n                ephemeral=True\n            )\n            return\n\n        if user_id in team1_queue:\n            await interaction.response.send_message(\n                \"Voc√™ j√° est√° no Time 1. Saia primeiro para entrar no Time 2.\",\n                ephemeral=True\n            )\n            return\n\n        if len(team2_queue) >= 2:\n            await interaction.response.send_message(\n                \"O Time 2 j√° est√° completo.\",\n                ephemeral=True\n            )\n            return\n\n        db.add_to_queue(team2_queue_id, user_id)\n        team2_queue = db.get_queue(team2_queue_id)\n\n        embed = discord.Embed(\n            title=\"‚úÖ Time 2\",\n            description=f\"{self.mode.replace('-', ' ').title()} - {len(team2_queue)}/2\",\n            color=EMBED_COLOR\n        )\n        if interaction.guild.icon:\n            embed.set_thumbnail(url=interaction.guild.icon.url)\n\n        await interaction.response.send_message(embed=embed, ephemeral=True)\n        await self.update_queue_message(interaction)\n\n        # Verifica se ambos os times est√£o completos\n        team1_queue = db.get_queue(team1_queue_id)\n        if len(team1_queue) == 2 and len(team2_queue) == 2:\n            await self.create_2v2_match(interaction.guild, team1_queue, team2_queue)\n\n    async def create_2v2_match(self, guild: discord.Guild, team1_queue: list, team2_queue: list):\n        \"\"\"Cria uma partida 2v2 quando ambos os times est√£o completos\"\"\"\n        team1_queue_id = f\"{self.queue_id}_team1\"\n        team2_queue_id = f\"{self.queue_id}_team2\"\n\n        # Remove todos os jogadores das filas\n        for user_id in team1_queue:\n            db.remove_from_queue(team1_queue_id, user_id)\n        for user_id in team2_queue:\n            db.remove_from_queue(team2_queue_id, user_id)\n\n        # Cria o canal da aposta 2v2\n        await create_2v2_bet_channel(guild, self.mode, team1_queue, team2_queue, self.bet_value, self.mediator_fee)\n\n\nclass ConfirmPaymentButton(discord.ui.View):\n    def __init__(self, bet_id: str):\n        super().__init__(timeout=None)\n        self.bet_id = bet_id\n\n    @discord.ui.button(label='Confirmar Pagamento', style=discord.ButtonStyle.green, emoji='üí∞')\n    async def confirm_payment_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        bet = db.get_active_bet(self.bet_id)\n\n        if not bet:\n            await interaction.response.send_message(\n                \"Esta aposta n√£o foi encontrada.\",\n                ephemeral=True\n            )\n            return\n\n        if bet.mediator_id == 0:\n            await interaction.response.send_message(\n                \"Aguarde um mediador aceitar esta aposta antes de confirmar pagamento.\",\n                ephemeral=True\n            )\n            return\n\n        user_id = interaction.user.id\n\n        if user_id == bet.player1_id:\n            if bet.player1_confirmed:\n                await interaction.response.send_message(\n                    \"Voc√™ j√° confirmou seu pagamento.\",\n                    ephemeral=True\n                )\n                return\n\n            bet.player1_confirmed = True\n            db.update_active_bet(bet)\n\n            player1 = await interaction.guild.fetch_member(bet.player1_id)\n            mediator = await interaction.guild.fetch_member(bet.mediator_id)\n\n            embed = discord.Embed(\n                title=\"‚úÖ Pagamento Confirmado\",\n                description=player1.mention,\n                color=EMBED_COLOR\n            )\n            await interaction.response.send_message(embed=embed)\n\n            try:\n                await mediator.send(f\"{player1.name} confirmou o pagamento na aposta {interaction.channel.mention}\")\n            except:\n                pass\n\n        elif user_id == bet.player2_id:\n            if bet.player2_confirmed:\n                await interaction.response.send_message(\n                    \"Voc√™ j√° confirmou seu pagamento.\",\n                    ephemeral=True\n                )\n                return\n\n            bet.player2_confirmed = True\n            db.update_active_bet(bet)\n\n            player2 = await interaction.guild.fetch_member(bet.player2_id)\n            mediator = await interaction.guild.fetch_member(bet.mediator_id)\n\n            embed = discord.Embed(\n                title=\"‚úÖ Pagamento Confirmado\",\n                description=player2.mention,\n                color=EMBED_COLOR\n            )\n            await interaction.response.send_message(embed=embed)\n\n            try:\n                await mediator.send(f\"{player2.name} confirmou o pagamento na aposta {interaction.channel.mention}\")\n            except:\n                pass\n        else:\n            await interaction.response.send_message(\n                \"Voc√™ n√£o √© um dos jogadores desta aposta.\",\n                ephemeral=True\n            )\n            return\n\n        if bet.is_fully_confirmed():\n            player1 = await interaction.guild.fetch_member(bet.player1_id)\n            player2 = await interaction.guild.fetch_member(bet.player2_id)\n\n            embed = discord.Embed(\n                title=\"‚úÖ Pagamentos Confirmados\",\n                description=\"Partida liberada\",\n                color=EMBED_COLOR\n            )\n\n            await interaction.channel.send(embed=embed)\n\n\nclass PixModal(discord.ui.Modal, title='Inserir Chave PIX'):\n    pix_key = discord.ui.TextInput(\n        label='Chave PIX',\n        placeholder='Digite sua chave PIX (CPF, telefone, email, etc)',\n        required=True,\n        max_length=100\n    )\n\n    def __init__(self, bet_id: str):\n        super().__init__()\n        self.bet_id = bet_id\n\n    async def on_submit(self, interaction: discord.Interaction):\n        bet = db.get_active_bet(self.bet_id)\n        if not bet:\n            await interaction.response.send_message(\"Aposta n√£o encontrada.\", ephemeral=True)\n            return\n\n        if bet.mediator_id != 0:\n            mediator = await interaction.guild.fetch_member(bet.mediator_id)\n            await interaction.response.send_message(\n                f\"Esta aposta j√° tem um mediador: {mediator.mention}\",\n                ephemeral=True\n            )\n            return\n\n        bet.mediator_id = interaction.user.id\n        bet.mediator_pix = str(self.pix_key.value)\n        db.update_active_bet(bet)\n\n        player1 = await interaction.guild.fetch_member(bet.player1_id)\n        player2 = await interaction.guild.fetch_member(bet.player2_id)\n\n        embed = discord.Embed(\n            title=\"Mediador Aceito\",\n            color=EMBED_COLOR\n        )\n        embed.add_field(name=\"Modo\", value=bet.mode.replace(\"-\", \" \").title(), inline=True)\n        embed.add_field(name=\"Jogadores\", value=f\"{player1.mention} vs {player2.mention}\", inline=False)\n        embed.add_field(name=\"Mediador\", value=interaction.user.mention, inline=True)\n        embed.add_field(name=\"PIX\", value=f\"`{bet.mediator_pix}`\", inline=True)\n        embed.add_field(name=\"Instru√ß√£o\", value=\"Envie o pagamento e clique no bot√£o abaixo para confirmar\", inline=False)\n        if interaction.guild.icon:\n            embed.set_thumbnail(url=interaction.guild.icon.url)\n\n        confirm_view = ConfirmPaymentButton(self.bet_id)\n        await interaction.response.send_message(embed=embed, view=confirm_view)\n\n        try:\n            original_message = await interaction.channel.fetch_message(interaction.message.id)\n            await original_message.edit(view=None)\n        except:\n            pass\n\n        channel = interaction.guild.get_channel(bet.channel_id)\n        if channel:\n            perms = channel.overwrites_for(interaction.user)\n            perms.read_messages = True\n            perms.send_messages = True\n            await channel.set_permissions(interaction.user, overwrite=perms)\n\n        try:\n            await player1.send(f\"Um mediador aceitou sua aposta. Acesse {channel.mention}\")\n        except:\n            pass\n\n        try:\n            await player2.send(f\"Um mediador aceitou sua aposta. Acesse {channel.mention}\")\n        except:\n            pass\n\n\nclass AcceptMediationButton(discord.ui.View):\n    def __init__(self, bet_id: str):\n        super().__init__(timeout=None)\n        self.bet_id = bet_id\n\n    @discord.ui.button(label='Aceitar Media√ß√£o', style=discord.ButtonStyle.green)\n    async def accept_button(self, interaction: discord.Interaction, button: discord.ui.Button):\n        bet = db.get_active_bet(self.bet_id)\n\n        if not bet:\n            await interaction.response.send_message(\"Aposta n√£o encontrada.\", ephemeral=True)\n            return\n\n        if bet.mediator_id != 0:\n            await interaction.response.send_message(\"Esta aposta j√° tem um mediador.\", ephemeral=True)\n            return\n\n        if not interaction.user.guild_permissions.administrator:\n            await interaction.response.send_message(\"Apenas administradores podem aceitar media√ß√£o.\", ephemeral=True)\n            return\n\n        await interaction.response.send_modal(PixModal(self.bet_id))\n\n\n@bot.event\nasync def on_ready():\n    print(f'Bot conectado como {bot.user}')\n    print(f'Nome: {bot.user.name}')\n    print(f'ID: {bot.user.id}')\n    try:\n        synced = await bot.tree.sync()\n        print(f'{len(synced)} comandos sincronizados')\n    except Exception as e:\n        print(f'Erro ao sincronizar comandos: {e}')\n\n\n\n\n\n@bot.tree.command(name=\"mostrar-fila\", description=\"[MODERADOR] Criar mensagem com bot√£o para entrar na fila\")\n@app_commands.describe(\n    modo=\"Escolha o modo de jogo\",\n    valor=\"Valor da aposta (exemplo: 5.00)\",\n    taxa=\"Taxa do mediador (exemplo: 0.50)\"\n)\n@app_commands.choices(modo=[\n    app_commands.Choice(name=\"1v1 Misto\", value=\"1v1-misto\"),\n    app_commands.Choice(name=\"1v1 Mob\", value=\"1v1-mob\"),\n    app_commands.Choice(name=\"2v2 Misto\", value=\"2v2-misto\"),\n])\nasync def mostrar_fila(interaction: discord.Interaction, modo: app_commands.Choice[str], valor: float, taxa: float):\n    if not interaction.user.guild_permissions.administrator:\n        await interaction.response.send_message(\n            \"Apenas moderadores podem usar este comando.\",\n            ephemeral=True\n        )\n        return\n\n    mode = modo.value\n\n    embed = discord.Embed(\n        title=modo.name,\n        color=EMBED_COLOR\n    )\n\n    embed.add_field(name=\"Valor\", value=f\"R$ {valor:.2f}\".replace('.', ','), inline=True)\n    embed.add_field(name=\"Fila\", value=\"Vazio\", inline=True)\n    if interaction.guild.icon:\n        embed.set_thumbnail(url=interaction.guild.icon.url)\n\n    await interaction.response.send_message(embed=embed)\n\n    # Pega a mensagem enviada para passar o ID para o bot√£o\n    message = await interaction.original_response()\n    view = QueueButton(mode, valor, taxa, message.id)\n\n    await message.edit(embed=embed, view=view)\n\n\n\n\n\n\n\n\nasync def create_2v2_bet_channel(guild: discord.Guild, mode: str, team1: list, team2: list, bet_value: float, mediator_fee: float):\n    \"\"\"Cria um canal de aposta para modo 2v2\"\"\"\n    # Verifica se algum jogador j√° est√° em aposta ativa\n    for user_id in team1 + team2:\n        if db.is_user_in_active_bet(user_id):\n            print(f\"Jogador {user_id} j√° est√° em uma aposta ativa. Abortando cria√ß√£o.\")\n            return\n\n    # Remove todos os jogadores de todas as filas\n    for user_id in team1 + team2:\n        db.remove_from_all_queues(user_id)\n\n    try:\n        # Busca os membros\n        team1_members = []\n        team2_members = []\n\n        for user_id in team1:\n            member = await guild.fetch_member(user_id)\n            team1_members.append(member)\n\n        for user_id in team2:\n            member = await guild.fetch_member(user_id)\n            team2_members.append(member)\n\n        category = discord.utils.get(guild.categories, name=ACTIVE_BETS_CATEGORY)\n        if not category:\n            category = await guild.create_category(ACTIVE_BETS_CATEGORY)\n\n        channel_name = f\"aposta-2v2-{team1_members[0].name}-{team1_members[1].name}-vs-{team2_members[0].name}-{team2_members[1].name}\"\n\n        overwrites = {\n            guild.default_role: discord.PermissionOverwrite(read_messages=False),\n            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)\n        }\n\n        # Adiciona permiss√µes para todos os jogadores\n        for member in team1_members + team2_members:\n            overwrites[member] = discord.PermissionOverwrite(read_messages=True, send_messages=True)\n\n        channel = await category.create_text_channel(name=channel_name, overwrites=overwrites)\n\n        # Cria ID da aposta com todos os jogadores\n        bet_id = f\"2v2_{team1[0]}_{team1[1]}_{team2[0]}_{team2[1]}_{int(datetime.now().timestamp())}\"\n\n        # Para 2v2, armazena como string separada por v√≠rgula\n        bet = Bet(\n            bet_id=bet_id,\n            mode=mode,\n            player1_id=team1[0],  # L√≠der do time 1\n            player2_id=team2[0],  # L√≠der do time 2\n            mediator_id=0,\n            channel_id=channel.id,\n            bet_value=bet_value,\n            mediator_fee=mediator_fee\n        )\n\n        # Adiciona campos customizados para 2v2\n        bet_dict = bet.to_dict()\n        bet_dict['team1'] = team1\n        bet_dict['team2'] = team2\n        bet_dict['is_2v2'] = True\n\n        # Salva manualmente com campos extras\n        data = db._load_data()\n        data['active_bets'][bet_id] = bet_dict\n        db._save_data(data)\n\n    except Exception as e:\n        print(f\"Erro ao criar canal de aposta 2v2: {e}\")\n        return\n\n    admin_role = discord.utils.get(guild.roles, permissions=discord.Permissions(administrator=True))\n    admin_mention = admin_role.mention if admin_role else \"@Administradores\"\n\n    team1_mentions = \" \".join([m.mention for m in team1_members])\n    team2_mentions = \" \".join([m.mention for m in team2_members])\n\n    embed = discord.Embed(\n        title=\"Aposta 2v2 - Aguardando Mediador\",\n        description=admin_mention,\n        color=EMBED_COLOR\n    )\n    embed.add_field(name=\"Modo\", value=mode.replace(\"-\", \" \").title(), inline=True)\n    embed.add_field(name=\"Valor/jogador\", value=f\"R$ {bet_value:.2f}\".replace('.', ','), inline=True)\n    embed.add_field(name=\"Taxa\", value=f\"R$ {mediator_fee:.2f}\".replace('.', ','), inline=True)\n    embed.add_field(name=\"Time 1\", value=team1_mentions, inline=True)\n    embed.add_field(name=\"Time 2\", value=team2_mentions, inline=True)\n    if guild.icon:\n        embed.set_thumbnail(url=guild.icon.url)\n\n    view = AcceptMediationButton(bet_id)\n\n    all_mentions = \" \".join([m.mention for m in team1_members + team2_members])\n    await channel.send(content=f\"{all_mentions} {admin_mention}\", embed=embed, view=view)\n\n    # Notifica todos os jogadores\n    for member in team1_members + team2_members:\n        try:\n            await member.send(f\"Sua aposta 2v2 foi criada. Aguardando mediador. Acesse {channel.mention}\")\n        except:\n            pass\n\n\nasync def create_bet_channel(guild: discord.Guild, mode: str, player1_id: int, player2_id: int, bet_value: float, mediator_fee: float):\n    if db.is_user_in_active_bet(player1_id) or db.is_user_in_active_bet(player2_id):\n        print(f\"Um dos jogadores j√° est√° em uma aposta ativa. Abortando cria√ß√£o.\")\n        return\n\n    db.remove_from_all_queues(player1_id)\n    db.remove_from_all_queues(player2_id)\n\n    try:\n        player1 = await guild.fetch_member(player1_id)\n        player2 = await guild.fetch_member(player2_id)\n\n        category = discord.utils.get(guild.categories, name=ACTIVE_BETS_CATEGORY)\n        if not category:\n            category = await guild.create_category(ACTIVE_BETS_CATEGORY)\n\n        channel_name = f\"aposta-{player1.name}-vs-{player2.name}\"\n\n        overwrites = {\n            guild.default_role: discord.PermissionOverwrite(read_messages=False),\n            player1: discord.PermissionOverwrite(read_messages=True, send_messages=True),\n            player2: discord.PermissionOverwrite(read_messages=True, send_messages=True),\n            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)\n        }\n\n        channel = await category.create_text_channel(name=channel_name, overwrites=overwrites)\n\n        bet_id = f\"{player1_id}_{player2_id}_{int(datetime.now().timestamp())}\"\n        bet = Bet(\n            bet_id=bet_id,\n            mode=mode,\n            player1_id=player1_id,\n            player2_id=player2_id,\n            mediator_id=0,\n            channel_id=channel.id,\n            bet_value=bet_value,\n            mediator_fee=mediator_fee\n        )\n        db.add_active_bet(bet)\n    except Exception as e:\n        print(f\"Erro ao criar canal de aposta: {e}\")\n        db.add_to_queue(mode, player1_id)\n        db.add_to_queue(mode, player2_id)\n        return\n\n    admin_role = discord.utils.get(guild.roles, permissions=discord.Permissions(administrator=True))\n    admin_mention = admin_role.mention if admin_role else \"@Administradores\"\n\n    embed = discord.Embed(\n        title=\"Aposta - Aguardando Mediador\",\n        description=admin_mention,\n        color=EMBED_COLOR\n    )\n    embed.add_field(name=\"Modo\", value=mode.replace(\"-\", \" \").title(), inline=True)\n    embed.add_field(name=\"Valor\", value=f\"R$ {bet_value:.2f}\".replace('.', ','), inline=True)\n    embed.add_field(name=\"Taxa\", value=f\"R$ {mediator_fee:.2f}\".replace('.', ','), inline=True)\n    embed.add_field(name=\"Jogadores\", value=f\"{player1.mention} vs {player2.mention}\", inline=False)\n    if guild.icon:\n        embed.set_thumbnail(url=guild.icon.url)\n\n    view = AcceptMediationButton(bet_id)\n\n    await channel.send(content=f\"{player1.mention} {player2.mention} {admin_mention}\", embed=embed, view=view)\n\n    try:\n        await player1.send(f\"Sua aposta foi criada. Aguardando mediador. Acesse {channel.mention}\")\n    except:\n        pass\n\n    try:\n        await player2.send(f\"Sua aposta foi criada. Aguardando mediador. Acesse {channel.mention}\")\n    except:\n        pass\n\n\n@bot.tree.command(name=\"confirmar-pagamento\", description=\"Confirmar que voc√™ enviou o pagamento ao mediador\")\nasync def confirmar_pagamento(interaction: discord.Interaction):\n    bet = db.get_bet_by_channel(interaction.channel_id)\n\n    if not bet:\n        await interaction.response.send_message(\n            \"Este canal n√£o √© uma aposta ativa.\",\n            ephemeral=True\n        )\n        return\n\n    if bet.mediator_id == 0:\n        await interaction.response.send_message(\n            \"Aguarde um mediador aceitar esta aposta antes de confirmar pagamento.\",\n            ephemeral=True\n        )\n        return\n\n    user_id = interaction.user.id\n\n    if user_id == bet.player1_id:\n        if bet.player1_confirmed:\n            await interaction.response.send_message(\n                \"Voc√™ j√° confirmou seu pagamento.\",\n                ephemeral=True\n            )\n            return\n\n        bet.player1_confirmed = True\n        db.update_active_bet(bet)\n\n        player1 = await interaction.guild.fetch_member(bet.player1_id)\n        mediator = await interaction.guild.fetch_member(bet.mediator_id)\n\n        embed = discord.Embed(\n            title=\"‚úÖ Pagamento Confirmado\",\n            description=player1.mention,\n            color=EMBED_COLOR\n        )\n        await interaction.response.send_message(embed=embed)\n\n        try:\n            await mediator.send(f\"{player1.name} confirmou o pagamento na aposta {interaction.channel.mention}\")\n        except:\n            pass\n\n    elif user_id == bet.player2_id:\n        if bet.player2_confirmed:\n            await interaction.response.send_message(\n                \"Voc√™ j√° confirmou seu pagamento.\",\n                ephemeral=True\n            )\n            return\n\n        bet.player2_confirmed = True\n        db.update_active_bet(bet)\n\n        player2 = await interaction.guild.fetch_member(bet.player2_id)\n        mediator = await interaction.guild.fetch_member(bet.mediator_id)\n\n        embed = discord.Embed(\n            title=\"‚úÖ Pagamento Confirmado\",\n            description=player2.mention,\n            color=EMBED_COLOR\n        )\n        await interaction.response.send_message(embed=embed)\n\n        try:\n            await mediator.send(f\"{player2.name} confirmou o pagamento na aposta {interaction.channel.mention}\")\n        except:\n            pass\n    else:\n        await interaction.response.send_message(\n            \"Voc√™ n√£o √© um dos jogadores desta aposta.\",\n            ephemeral=True\n        )\n        return\n\n    if bet.is_fully_confirmed():\n        player1 = await interaction.guild.fetch_member(bet.player1_id)\n        player2 = await interaction.guild.fetch_member(bet.player2_id)\n\n        embed = discord.Embed(\n            title=\"‚úÖ Pagamentos Confirmados\",\n            description=\"Partida liberada\",\n            color=EMBED_COLOR\n        )\n\n        await interaction.channel.send(embed=embed)\n\n\n@bot.tree.command(name=\"finalizar-aposta\", description=\"[MEDIADOR] Finalizar a aposta e declarar vencedor\")\n@app_commands.describe(vencedor=\"Mencione o jogador vencedor\")\nasync def finalizar_aposta(interaction: discord.Interaction, vencedor: discord.Member):\n    bet = db.get_bet_by_channel(interaction.channel_id)\n\n    if not bet:\n        await interaction.response.send_message(\n            \"Este canal n√£o √© uma aposta ativa.\",\n            ephemeral=True\n        )\n        return\n\n    if interaction.user.id != bet.mediator_id:\n        await interaction.response.send_message(\n            \"Apenas o mediador pode finalizar esta aposta.\",\n            ephemeral=True\n        )\n        return\n\n    if vencedor.id not in [bet.player1_id, bet.player2_id]:\n        await interaction.response.send_message(\n            \"O vencedor deve ser um dos jogadores desta aposta.\",\n            ephemeral=True\n        )\n        return\n\n    bet.winner_id = vencedor.id\n    bet.finished_at = datetime.now().isoformat()\n\n    player1 = await interaction.guild.fetch_member(bet.player1_id)\n    player2 = await interaction.guild.fetch_member(bet.player2_id)\n    loser = player1 if vencedor.id == bet.player2_id else player2\n\n    embed = discord.Embed(\n        title=\"üèÜ Vencedor\",\n        description=vencedor.mention,\n        color=EMBED_COLOR\n    )\n    embed.add_field(name=\"Modo\", value=bet.mode.replace(\"-\", \" \").title(), inline=True)\n    embed.add_field(name=\"Perdedor\", value=loser.mention, inline=True)\n\n    await interaction.response.send_message(embed=embed)\n\n    db.finish_bet(bet)\n\n    import asyncio\n    await asyncio.sleep(10)\n\n    try:\n        await interaction.channel.delete()\n    except:\n        pass\n\n\n@bot.tree.command(name=\"cancelar-aposta\", description=\"[MEDIADOR] Cancelar uma aposta em andamento\")\nasync def cancelar_aposta(interaction: discord.Interaction):\n    bet = db.get_bet_by_channel(interaction.channel_id)\n\n    if not bet:\n        await interaction.response.send_message(\n            \"Este canal n√£o √© uma aposta ativa.\",\n            ephemeral=True\n        )\n        return\n\n    if interaction.user.id != bet.mediator_id:\n        await interaction.response.send_message(\n            \"Apenas o mediador pode cancelar esta aposta.\",\n            ephemeral=True\n        )\n        return\n\n    player1 = await interaction.guild.fetch_member(bet.player1_id)\n    player2 = await interaction.guild.fetch_member(bet.player2_id)\n\n    embed = discord.Embed(\n        title=\"‚ùå Aposta Cancelada\",\n        description=f\"{player1.mention} e {player2.mention}\",\n        color=EMBED_COLOR\n    )\n\n    await interaction.response.send_message(embed=embed)\n\n    bet.finished_at = datetime.now().isoformat()\n    db.finish_bet(bet)\n\n    import asyncio\n    await asyncio.sleep(10)\n\n    try:\n        await interaction.channel.delete()\n    except:\n        pass\n\n\n@bot.tree.command(name=\"historico\", description=\"Ver o hist√≥rico de apostas\")\nasync def historico(interaction: discord.Interaction):\n    history = db.get_bet_history()\n\n    if not history:\n        await interaction.response.send_message(\n            \"Ainda n√£o h√° hist√≥rico de apostas.\",\n            ephemeral=True\n        )\n        return\n\n    embed = discord.Embed(\n        title=\"Hist√≥rico de Apostas\",\n        description=f\"Total de apostas: {len(history)}\",\n        color=EMBED_COLOR\n    )\n\n    for bet in history[-10:]:\n        winner_mention = f\"<@{bet.winner_id}>\" if bet.winner_id else \"Cancelada\"\n        embed.add_field(\n            name=f\"{bet.mode.replace('-', ' ').title()}\",\n            value=(\n                f\"Jogadores: <@{bet.player1_id}> vs <@{bet.player2_id}>\\n\"\n                f\"Vencedor: {winner_mention}\\n\"\n                f\"Data: {bet.finished_at[:10] if bet.finished_at else 'N/A'}\"\n            ),\n            inline=False\n        )\n    if interaction.guild.icon:\n        embed.set_thumbnail(url=interaction.guild.icon.url)\n\n    await interaction.response.send_message(embed=embed)\n\n\n@bot.tree.command(name=\"minhas-apostas\", description=\"Ver suas apostas ativas\")\nasync def minhas_apostas(interaction: discord.Interaction):\n    user_id = interaction.user.id\n    active_bets = db.get_all_active_bets()\n\n    user_bets = [bet for bet in active_bets.values() \n                 if bet.player1_id == user_id or bet.player2_id == user_id]\n\n    if not user_bets:\n        await interaction.response.send_message(\n            \"Voc√™ n√£o tem apostas ativas no momento.\",\n            ephemeral=True\n        )\n        return\n\n    embed = discord.Embed(\n        title=\"Suas Apostas Ativas\",\n        description=f\"Voc√™ tem {len(user_bets)} aposta(s) ativa(s)\",\n        color=EMBED_COLOR\n    )\n\n    for bet in user_bets:\n        channel = f\"<#{bet.channel_id}>\"\n        status = \"Confirmada\" if (\n            (user_id == bet.player1_id and bet.player1_confirmed) or \n            (user_id == bet.player2_id and bet.player2_confirmed)\n        ) else \"Aguardando confirma√ß√£o\"\n\n        embed.add_field(\n            name=f\"{bet.mode.replace('-', ' ').title()}\",\n            value=f\"Canal: {channel}\\nStatus: {status}\",\n            inline=False\n        )\n    if interaction.guild.icon:\n        embed.set_thumbnail(url=interaction.guild.icon.url)\n\n    await interaction.response.send_message(embed=embed, ephemeral=True)\n\n\n@bot.tree.command(name=\"desbugar-filas\", description=\"[ADMIN] Cancelar todas as apostas ativas e limpar filas\")\nasync def desbugar_filas(interaction: discord.Interaction):\n    if not interaction.user.guild_permissions.administrator:\n        await interaction.response.send_message(\n            \"Apenas administradores podem usar este comando.\",\n            ephemeral=True\n        )\n        return\n\n    active_bets = db.get_all_active_bets()\n\n    if not active_bets:\n        await interaction.response.send_message(\n            \"N√£o h√° apostas ativas para cancelar.\",\n            ephemeral=True\n        )\n        return\n\n    # Defer a resposta porque pode demorar\n    await interaction.response.defer()\n\n    deleted_channels = 0\n    cancelled_bets = 0\n\n    # Cancelar todas as apostas ativas\n    for bet_id, bet in list(active_bets.items()):\n        try:\n            channel = interaction.guild.get_channel(bet.channel_id)\n            if channel:\n                await channel.delete()\n                deleted_channels += 1\n        except:\n            pass\n\n        # Mover para hist√≥rico sem vencedor (cancelada)\n        bet.finished_at = datetime.now().isoformat()\n        db.finish_bet(bet)\n        cancelled_bets += 1\n\n    # Limpar todas as filas\n    data = db._load_data()\n    data['queues'] = {}\n    db._save_data(data)\n\n    embed = discord.Embed(\n        title=\"Sistema Desbugado\",\n        description=\"Todas as apostas ativas foram canceladas e as filas limpas.\",\n        color=EMBED_COLOR\n    )\n    embed.add_field(name=\"Apostas Canceladas\", value=str(cancelled_bets), inline=True)\n    embed.add_field(name=\"Canais Deletados\", value=str(deleted_channels), inline=True)\n    embed.add_field(name=\"Filas Limpas\", value=\"Todas\", inline=True)\n    embed.set_footer(text=f\"Executado por {interaction.user.name}\")\n    if interaction.guild.icon:\n        embed.set_thumbnail(url=interaction.guild.icon.url)\n\n    await interaction.followup.send(embed=embed)\n\n\n@bot.tree.command(name=\"ajuda\", description=\"Ver todos os comandos dispon√≠veis\")\nasync def ajuda(interaction: discord.Interaction):\n    embed = discord.Embed(\n        title=\"NZ Apostado - Comandos\",\n        description=\"Sistema de apostas profissional\",\n        color=EMBED_COLOR\n    )\n\n    embed.add_field(\n        name=\"Comandos para Jogadores\",\n        value=(\n            \"`/confirmar-pagamento` - Confirmar que enviou o pagamento\\n\"\n            \"`/minhas-apostas` - Ver suas apostas ativas\\n\"\n            \"`/historico` - Ver hist√≥rico de apostas\"\n        ),\n        inline=False\n    )\n\n    embed.add_field(\n        name=\"Comandos para Mediadores/Moderadores\",\n        value=(\n            \"`/mostrar-fila` - Criar mensagem com bot√£o para entrar na fila\\n\"\n            \"`/finalizar-aposta` - Finalizar aposta e declarar vencedor\\n\"\n            \"`/cancelar-aposta` - Cancelar uma aposta\\n\"\n            \"`/desbugar-filas` - [ADMIN] Cancelar todas apostas e limpar filas\"\n        ),\n        inline=False\n    )\n\n    embed.add_field(\n        name=\"Como Funciona\",\n        value=(\n            \"1. Moderadores criam filas com `/mostrar-fila`\\n\"\n            \"2. Clique no bot√£o 'Entrar na Fila' da mensagem\\n\"\n            \"3. Quando encontrar outro jogador, um canal privado ser√° criado\\n\"\n            \"4. Envie o valor da aposta para o mediador\\n\"\n            \"5. Confirme com `/confirmar-pagamento`\\n\"\n            \"6. Jogue a partida\\n\"\n            \"7. O mediador declara o vencedor com `/finalizar-aposta`\"\n        ),\n        inline=False\n    )\n    if interaction.guild.icon:\n        embed.set_thumbnail(url=interaction.guild.icon.url)\n\n    await interaction.response.send_message(embed=embed)\n\n\ntry:\n    token = os.getenv(\"TOKEN\") or \"\"\n    if token == \"\":\n        raise Exception(\"Por favor, adicione seu token do Discord nas vari√°veis de ambiente (TOKEN).\")\n    \n    if IS_RAILWAY:\n        print(\"Iniciando bot no Railway...\")\n        # Railway requer que o processo n√£o morra, ent√£o usamos configura√ß√µes espec√≠ficas\n        bot.run(token, log_handler=None, root_logger=True)\n    else:\n        print(\"Iniciando bot no Replit/Local...\")\n        bot.run(token)\n        \nexcept discord.HTTPException as e:\n    if e.status == 429:\n        print(\"O Discord bloqueou a conex√£o por excesso de requisi√ß√µes\")\n        print(\"Veja: https://stackoverflow.com/questions/66724687/in-discord-py-how-to-solve-the-error-for-toomanyrequests\")\n    else:\n        raise e\nexcept Exception as e:\n    print(f\"Erro ao iniciar o bot: {e}\")\n    if IS_RAILWAY:\n        # No Railway, queremos saber exatamente o que deu errado\n        import traceback\n        traceback.print_exc()\n        raise","size_bytes":42927},"nz-apostas/utils/database.py":{"content":"import json\nimport os\nfrom typing import Dict, List, Optional\nfrom models.bet import Bet\n\n\nclass Database:\n    \"\"\"Gerencia o armazenamento de dados do bot\"\"\"\n\n    def __init__(self, data_dir: str = \"data\"):\n        # Detectar ambiente Railway\n        is_railway = os.getenv(\"RAILWAY_ENVIRONMENT\") is not None or os.getenv(\"RAILWAY_STATIC_URL\") is not None\n\n        if is_railway:\n            # No Railway, usar /app/data se existir, sen√£o criar no diret√≥rio atual\n            self.data_dir = \"/app/data\" if os.path.exists(\"/app\") else data_dir\n        else:\n            self.data_dir = data_dir\n\n        self.data_file = os.path.join(self.data_dir, \"bets.json\")\n\n        self._ensure_file_exists()\n\n    def _ensure_file_exists(self):\n        \"\"\"Garante que o arquivo de dados existe\"\"\"\n        os.makedirs(os.path.dirname(self.data_file), exist_ok=True)\n        if not os.path.exists(self.data_file):\n            self._save_data({'queues': {}, 'active_bets': {}, 'bet_history': []})\n\n    def _load_data(self) -> dict:\n        \"\"\"Carrega dados do arquivo\"\"\"\n        with open(self.data_file, 'r', encoding='utf-8') as f:\n            return json.load(f)\n\n    def _save_data(self, data: dict):\n        \"\"\"Salva dados no arquivo\"\"\"\n        with open(self.data_file, 'w', encoding='utf-8') as f:\n            json.dump(data, f, indent=2, ensure_ascii=False)\n\n    def add_to_queue(self, queue_id: str, user_id: int):\n        \"\"\"Adiciona um jogador √† fila\"\"\"\n        data = self._load_data()\n        if queue_id not in data['queues']:\n            data['queues'][queue_id] = []\n        if user_id not in data['queues'][queue_id]:\n            data['queues'][queue_id].append(user_id)\n        self._save_data(data)\n\n    def remove_from_queue(self, queue_id: str, user_id: int):\n        \"\"\"Remove um jogador da fila\"\"\"\n        data = self._load_data()\n        if queue_id in data['queues'] and user_id in data['queues'][queue_id]:\n            data['queues'][queue_id].remove(user_id)\n        self._save_data(data)\n\n    def get_queue(self, queue_id: str) -> List[int]:\n        \"\"\"Retorna a fila de um painel espec√≠fico\"\"\"\n        data = self._load_data()\n        return data['queues'].get(queue_id, [])\n\n    def remove_from_all_queues(self, user_id: int):\n        \"\"\"Remove um jogador de todas as filas\"\"\"\n        data = self._load_data()\n        for mode in data['queues']:\n            if user_id in data['queues'][mode]:\n                data['queues'][mode].remove(user_id)\n        self._save_data(data)\n\n    def is_user_in_active_bet(self, user_id: int) -> bool:\n        \"\"\"Verifica se um jogador est√° em uma aposta ativa\"\"\"\n        data = self._load_data()\n        for bet_data in data['active_bets'].values():\n            if bet_data['player1_id'] == user_id or bet_data['player2_id'] == user_id:\n                return True\n        return False\n\n    def add_active_bet(self, bet: Bet):\n        \"\"\"Adiciona uma aposta ativa\"\"\"\n        data = self._load_data()\n        data['active_bets'][bet.bet_id] = bet.to_dict()\n        self._save_data(data)\n\n    def get_active_bet(self, bet_id: str) -> Optional[Bet]:\n        \"\"\"Retorna uma aposta ativa pelo ID\"\"\"\n        data = self._load_data()\n        bet_data = data['active_bets'].get(bet_id)\n        return Bet.from_dict(bet_data) if bet_data else None\n\n    def get_bet_by_channel(self, channel_id: int) -> Optional[Bet]:\n        \"\"\"Retorna uma aposta pelo ID do canal\"\"\"\n        data = self._load_data()\n        for bet_data in data['active_bets'].values():\n            if bet_data['channel_id'] == channel_id:\n                return Bet.from_dict(bet_data)\n        return None\n\n    def update_active_bet(self, bet: Bet):\n        \"\"\"Atualiza uma aposta ativa\"\"\"\n        data = self._load_data()\n        data['active_bets'][bet.bet_id] = bet.to_dict()\n        self._save_data(data)\n\n    def finish_bet(self, bet: Bet):\n        \"\"\"Finaliza uma aposta e move para o hist√≥rico\"\"\"\n        data = self._load_data()\n        if bet.bet_id in data['active_bets']:\n            del data['active_bets'][bet.bet_id]\n            data['bet_history'].append(bet.to_dict())\n            self._save_data(data)\n\n    def get_bet_history(self) -> List[Bet]:\n        \"\"\"Retorna o hist√≥rico de apostas\"\"\"\n        data = self._load_data()\n        return [Bet.from_dict(bet_data) for bet_data in data['bet_history']]\n\n    def get_all_active_bets(self) -> Dict[str, Bet]:\n        \"\"\"Retorna todas as apostas ativas\"\"\"\n        data = self._load_data()\n        return {bet_id: Bet.from_dict(bet_data) for bet_id, bet_data in data['active_bets'].items()}","size_bytes":4570},"nz-apostas/utils/__init__.py":{"content":"","size_bytes":0},"nz-apostas/pyproject.toml":{"content":"[tool.poetry]\nname = \"python-template\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Your Name <you@example.com>\"]\n\n[tool.poetry.dependencies]\npython = \">=3.10.0,<3.11\"\ndiscord-py = \"^2.6.4\"\n\n[tool.pyright]\n# https://github.com/microsoft/pyright/blob/main/docs/configuration.md\nuseLibraryCodeForTypes = true\n\n[tool.ruff]\n# https://beta.ruff.rs/docs/configuration/\nselect = ['E', 'W', 'F', 'I', 'B', 'C4', 'ARG', 'SIM']\nignore = ['W291', 'W292', 'W293']\n\n[build-system]\nrequires = [\"poetry-core>=1.0.0\"]\nbuild-backend = \"poetry.core.masonry.api\"","size_bytes":545},"nz-apostas/models/bet.py":{"content":"from dataclasses import dataclass\nfrom typing import Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Bet:\n    \"\"\"Representa uma aposta ativa\"\"\"\n    bet_id: str\n    mode: str\n    player1_id: int\n    player2_id: int\n    mediator_id: int\n    channel_id: int\n    bet_value: float = 0.0\n    mediator_fee: float = 0.0\n    mediator_pix: Optional[str] = None\n    player1_confirmed: bool = False\n    player2_confirmed: bool = False\n    winner_id: Optional[int] = None\n    created_at: str = \"\"\n    finished_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def is_fully_confirmed(self) -> bool:\n        \"\"\"Verifica se ambos os jogadores confirmaram pagamento\"\"\"\n        return self.player1_confirmed and self.player2_confirmed\n    \n    def to_dict(self) -> dict:\n        \"\"\"Converte a aposta para dicion√°rio\"\"\"\n        return {\n            'bet_id': self.bet_id,\n            'mode': self.mode,\n            'player1_id': self.player1_id,\n            'player2_id': self.player2_id,\n            'mediator_id': self.mediator_id,\n            'channel_id': self.channel_id,\n            'bet_value': self.bet_value,\n            'mediator_fee': self.mediator_fee,\n            'mediator_pix': self.mediator_pix,\n            'player1_confirmed': self.player1_confirmed,\n            'player2_confirmed': self.player2_confirmed,\n            'winner_id': self.winner_id,\n            'created_at': self.created_at,\n            'finished_at': self.finished_at\n        }\n    \n    @classmethod\n    def from_dict(cls, data: dict) -> 'Bet':\n        \"\"\"Cria uma aposta a partir de um dicion√°rio\"\"\"\n        return cls(**data)\n","size_bytes":1714},"nz-apostas/README.md":{"content":"# NZ Apostas - Bot Discord\n\nBot profissional de apostas para Discord com sistema de filas, media√ß√£o e hist√≥rico.\n\n## Features\n\n- ‚úÖ Sistema de filas 1v1 e 2v2\n- ‚úÖ Media√ß√£o de apostas com confirma√ß√£o de pagamento\n- ‚úÖ M√∫ltiplos modos de jogo (Misto, Mob)\n- ‚úÖ Hist√≥rico de apostas\n- ‚úÖ Canais privados autom√°ticos\n- ‚úÖ Sistema de PIX para mediadores\n- ‚úÖ Comandos administrativos\n\n## Deploy\n\n### Replit (Principal)\n\nEste bot est√° configurado para rodar no Replit. Basta clicar no bot√£o **Run** para iniciar.\n\n**Vari√°veis de Ambiente:**\n- `TOKEN`: Token do bot Discord\n\n### Railway (Backup)\n\nPara deploy no Railway, consulte o guia completo: [DEPLOY_RAILWAY.md](DEPLOY_RAILWAY.md)\n\n## Comandos\n\n### Jogadores\n- `/confirmar-pagamento` - Confirmar envio do pagamento\n- `/minhas-apostas` - Ver apostas ativas\n- `/historico` - Ver hist√≥rico de apostas\n\n### Moderadores\n- `/mostrar-fila` - Criar fila com bot√µes\n- `/finalizar-aposta` - Declarar vencedor\n- `/cancelar-aposta` - Cancelar aposta\n\n### Administradores\n- `/desbugar-filas` - Limpar sistema (emerg√™ncia)\n\n## Como Usar\n\n1. Moderador cria fila com `/mostrar-fila`\n2. Jogadores clicam em \"Entrar na Fila\" (1v1) ou escolhem time (2v2)\n3. Sistema cria canal privado automaticamente\n4. Mediador aceita e fornece PIX\n5. Jogadores enviam pagamento e confirmam\n6. Partida √© liberada\n7. Mediador declara vencedor com `/finalizar-aposta`\n\n## Estrutura\n\n```\nnz-apostas/\n‚îú‚îÄ‚îÄ main.py              # Bot principal\n‚îú‚îÄ‚îÄ models/\n‚îÇ   ‚îî‚îÄ‚îÄ bet.py          # Modelo de aposta\n‚îú‚îÄ‚îÄ utils/\n‚îÇ   ‚îî‚îÄ‚îÄ database.py     # Sistema de dados\n‚îú‚îÄ‚îÄ data/\n‚îÇ   ‚îî‚îÄ‚îÄ bets.json       # Dados persistentes\n‚îî‚îÄ‚îÄ DEPLOY_RAILWAY.md   # Guia Railway\n```\n\n## Desenvolvimento\n\n**Depend√™ncias:**\n- Python 3.10\n- discord.py 2.6.4\n\n**Instala√ß√£o Local:**\n```bash\npip install discord.py\npython main.py\n```\n\n## Troubleshooting\n\n### 429 Too Many Requests\nSe voc√™ receber este erro, veja: https://stackoverflow.com/questions/66724687/in-discord-py-how-to-solve-the-error-for-toomanyrequests\n\n### Bot n√£o conecta\n- Verifique se o TOKEN est√° configurado\n- Confirme que o bot tem as permiss√µes necess√°rias no servidor\n\n### Comandos n√£o aparecem\n- Aguarde at√© 1 hora para sincroniza√ß√£o global\n- Ou remova/readicione o bot ao servidor\n\n## Suporte\n\nPara d√∫vidas sobre configura√ß√£o do bot Discord, consulte:\n- [Documenta√ß√£o discord.py](https://discordpy.readthedocs.io/)\n- [Discord Developer Portal](https://discord.com/developers/applications)\n\n---\n\n**Deploy Principal**: Replit  \n**Deploy Backup**: Railway ([Ver guia](DEPLOY_RAILWAY.md))","size_bytes":2624}},"version":2}